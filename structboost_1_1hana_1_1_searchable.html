<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Boost.Hana: boost::hana::Searchable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Heterogeneous combinators for expressive metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_searchable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="#nested-classes">Instances and minimal complete definitions</a> &#124;
<a href="structboost_1_1hana_1_1_searchable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Searchable Struct Reference<div class="ingroups"><a class="el" href="group__group-typeclasses.html">Type classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Data structures that can be searched. </p>
<p><code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="Data structures that can be searched. ">Searchable</a></code>s are structures associating keys to values. Some methods like <code>any</code>, <code>all</code> and <code>none</code> allow simple queries to be performed on the keys of the structure, while other methods like <code>lookup</code> and <code>find</code> make it possible to find the value associated to a key. Unlike usual associative containers, <code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="Data structures that can be searched. ">Searchable</a></code> does not require the structure to be finite; its specification is voluntarily left very general to allow infinite data structures. Also, there is no requirement that the keys and values be different, and indeed it is often useful to have identical keys and values.</p>
<p>Also note that the most specific method should always be used if one cares about performance. For example, an associative data structure implemented as a hash table will be much faster to access using <code>lookup</code> than <code>find</code>. Similarly, using <code>elem</code> will likely be much faster than <code>any</code> with an equivalent predicate. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a></td></tr>
<tr class="memdesc:a67dd29f7921b76f7d2bd372605f73f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any key of the structure satisfies the <code>predicate</code>.  <a href="#a67dd29f7921b76f7d2bd372605f73f7c">More...</a><br /></td></tr>
<tr class="separator:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc05dc4553467aa0a2235088de41b4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a></td></tr>
<tr class="memdesc:a2dc05dc4553467aa0a2235088de41b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether any key of the structure is true-valued.  <a href="#a2dc05dc4553467aa0a2235088de41b4b">More...</a><br /></td></tr>
<tr class="separator:a2dc05dc4553467aa0a2235088de41b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a></td></tr>
<tr class="memdesc:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the keys of the structure satisfy the <code>predicate</code>.  <a href="#a695907e4a3ef7d0e9ab34f5afff709b2">More...</a><br /></td></tr>
<tr class="separator:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd57241c497cbe1a2ce5ac57549080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a></td></tr>
<tr class="memdesc:adadd57241c497cbe1a2ce5ac57549080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all the keys of the structure are true-valued.  <a href="#adadd57241c497cbe1a2ce5ac57549080">More...</a><br /></td></tr>
<tr class="separator:adadd57241c497cbe1a2ce5ac57549080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365b793fe547271e48fa719a7f4854d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a></td></tr>
<tr class="memdesc:a9365b793fe547271e48fa719a7f4854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether none of the keys of the structure satisfy the <code>predicate</code>.  <a href="#a9365b793fe547271e48fa719a7f4854d">More...</a><br /></td></tr>
<tr class="separator:a9365b793fe547271e48fa719a7f4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a></td></tr>
<tr class="memdesc:abf1dbf83a1d98c62994e207ea18eea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether all of the keys of the structure are false-valued.  <a href="#abf1dbf83a1d98c62994e207ea18eea8a">More...</a><br /></td></tr>
<tr class="separator:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a></td></tr>
<tr class="memdesc:a04e413e4acd1dac89e442df2f30f3e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.  <a href="#a04e413e4acd1dac89e442df2f30f3e2d">More...</a><br /></td></tr>
<tr class="separator:a04e413e4acd1dac89e442df2f30f3e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a></td></tr>
<tr class="memdesc:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value associated to the first key satisfying a predicate.  <a href="#a2772d97163d2e2ca3f51b2d16d13ff66">More...</a><br /></td></tr>
<tr class="separator:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e67ada9561f5e1176faab8eb94a064"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a></td></tr>
<tr class="memdesc:a82e67ada9561f5e1176faab8eb94a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the value associated to the given key in a structure.  <a href="#a82e67ada9561f5e1176faab8eb94a064">More...</a><br /></td></tr>
<tr class="separator:a82e67ada9561f5e1176faab8eb94a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234e4ee0bd5e0e9e604d6140fde24074"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a></td></tr>
<tr class="memdesc:a234e4ee0bd5e0e9e604d6140fde24074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.  <a href="#a234e4ee0bd5e0e9e604d6140fde24074">More...</a><br /></td></tr>
<tr class="separator:a234e4ee0bd5e0e9e604d6140fde24074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713b34e28603ea39c8873609fd24801"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable.html#aa713b34e28603ea39c8873609fd24801">subset</a></td></tr>
<tr class="memdesc:aa713b34e28603ea39c8873609fd24801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a structure contains a subset of the keys of another structure.  <a href="#aa713b34e28603ea39c8873609fd24801">More...</a><br /></td></tr>
<tr class="separator:aa713b34e28603ea39c8873609fd24801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Instances and minimal complete definitions</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_map_01_4.html">instance&lt; Map &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map can be searched by its keys with a predicate yielding a <a class="el" href="structboost_1_1hana_1_1_logical.html#Logical_terminology">compile-time</a> <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.  <a href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_map_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_maybe_01_4.html">instance&lt; Maybe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of <code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="Data structures that can be searched. ">Searchable</a></code> for <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>s.  <a href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_maybe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_set_01_4.html">instance&lt; Set &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The keys and the values of a <code><a class="el" href="structboost_1_1hana_1_1_set.html" title="A basic unordered container requiring Comparable elements. ">Set</a></code> are its elements; the <code><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="Data structures that can be searched. ">Searchable</a></code>Â  instance follows naturally from that.  <a href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_set_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1list__mcd.html">list_mcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal complete definition: <code><a class="el" href="structboost_1_1hana_1_1_list.html" title="General purpose index-based sequence. ">List</a></code>  <a href="structboost_1_1hana_1_1_searchable_1_1list__mcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1mcd.html">mcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal complete definition: <code>find</code> and <code>any</code>  <a href="structboost_1_1hana_1_1_searchable_1_1mcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_searchable_1_1record__mcd.html">record_mcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal complete definition: <code><a class="el" href="structboost_1_1hana_1_1_record.html" title="Represents record-like user-defined types. ">Record</a></code>  <a href="structboost_1_1hana_1_1_searchable_1_1record__mcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a67dd29f7921b76f7d2bd372605f73f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::any_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether any key of the structure satisfies the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to be satisfied after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(tuple(1, 2), odd));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(tuple(2_c, 4_c), odd));</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(tuple(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_void&gt;)</div>
<div class="line">        );</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            !<a class="code" href="structboost_1_1hana_1_1_searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(tuple(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_integral&gt;)</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="any.time.png" alt="any.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a2dc05dc4553467aa0a2235088de41b4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::any_of_impl(detail::std::forward&lt;decltype(searchable)&gt;(searchable));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether any key of the structure is true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(tuple(<span class="keyword">false</span>, false_, true_)));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(tuple(<span class="keyword">false</span>, false_, <span class="keyword">true</span>)));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(tuple(<span class="keyword">false</span>, false_, false_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a695907e4a3ef7d0e9ab34f5afff709b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::all_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a false- valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(tuple(1, 3), odd));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(tuple(3_c, 4_c), odd));</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            !<a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(tuple(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_void&gt;)</div>
<div class="line">        );</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(tuple(type&lt;int&gt;, type&lt;char&gt;), trait&lt;std::is_integral&gt;)</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="all.time.png" alt="all.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="adadd57241c497cbe1a2ce5ac57549080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::all_of_impl(detail::std::forward&lt;decltype(searchable)&gt;(searchable));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all the keys of the structure are true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>s. If the structure is not finite, a false-valued key must appear at a finite "index" in order for this method to finish.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(tuple(true_, <span class="keyword">true</span>, true_)));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(tuple(<span class="keyword">true</span>, false_, true_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9365b793fe547271e48fa719a7f4854d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::none_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether none of the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a true- valued <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <span class="keyword">using namespace </span>literals;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(tuple(2_c, 4_c), odd));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(tuple(1, 2), odd));</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            !<a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(tuple(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_void&gt;)</div>
<div class="line">        );</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            <a class="code" href="structboost_1_1hana_1_1_searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(tuple(type&lt;void&gt;, type&lt;char&amp;&gt;), trait&lt;std::is_integral&gt;)</div>
<div class="line">        );</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="none.time.png" alt="none.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="abf1dbf83a1d98c62994e207ea18eea8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::none_of_impl(detail::std::forward&lt;decltype(searchable)&gt;(searchable));</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether all of the keys of the structure are false-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(tuple(<span class="keyword">false</span>, false_, false_)));</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(tuple(<span class="keyword">false</span>, false_, <span class="keyword">true</span>)));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(!<a class="code" href="structboost_1_1hana_1_1_searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(tuple(<span class="keyword">false</span>, false_, true_)));</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a04e413e4acd1dac89e442df2f30f3e2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable, <span class="keyword">auto</span>&amp;&amp; key) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::elem_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(key)&gt;(key)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether the key occurs in the structure. </p>
<p>Specifically, returns whether any of the keys of the structure is equal to the given <code>key</code>. If the structure is not finite, an equal key has to appear at a finite "index" in the structure for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> with the other keys of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(tuple(2, int_&lt;2&gt;, int_&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>), int_&lt;3&gt;));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(set(1, <span class="charliteral">&#39;2&#39;</span>, type&lt;int&gt;, <span class="stringliteral">&quot;foobar&quot;</span>), type&lt;int&gt;));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="elem.time.png" alt="elem.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a2772d97163d2e2ca3f51b2d16d13ff66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::find_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(predicate)&gt;(predicate)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Find the value associated to the first key satisfying a predicate. </p>
<p>Specifically, returns <code>just</code> the first value whose key satisfies the <code>predicate</code>, or <code>nothing</code> if there is no such key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>. Note that in the current version of the library, the <code>predicate</code> has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>, i.e. one allowing values of different types in <code>if_</code>. This is because <code>find</code> returns a <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>, which is an heterogeneous data type.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(tuple(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), trait_&lt;std::is_integral&gt;) == just(2));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(tuple(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), trait_&lt;std::is_class&gt;) == nothing);</div>
<div class="line"></div>
<div class="line">        constexpr <span class="keyword">auto</span> types = type_list&lt;char, int, unsigned, long, unsigned long&gt;;</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(types, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == type&lt;unsigned&gt;) == just(type&lt;unsigned&gt;));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(types, <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> == type&lt;void&gt;) == nothing);</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="find.time.png" alt="find.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a82e67ada9561f5e1176faab8eb94a064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto lookup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; searchable, <span class="keyword">auto</span>&amp;&amp; key) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(searchable)&gt;</div>
<div class="line">        &gt;::lookup_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(key)&gt;(key)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Find the value associated to the given key in a structure. </p>
<p>Specifically, returns <code>just</code> the first value whose key is equal to the given <code>key</code>, or <code>nothing</code> if there is no such key. Comparison is done with <code>equal</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code>, i.e. one allowing values of different types in <code>if_</code>. This is because <code>lookup</code> returns a <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>, which is an heterogeneous data type.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a>(tuple(int_&lt;1&gt;, type&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), type&lt;int&gt;) == just(type&lt;int&gt;));</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a>(tuple(int_&lt;1&gt;, type&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), type&lt;void&gt;) == nothing);</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> m = map(</div>
<div class="line">            pair(1, <span class="charliteral">&#39;x&#39;</span>),</div>
<div class="line">            pair(type&lt;float&gt;, 3.3),</div>
<div class="line">            pair(type&lt;char&gt;, type&lt;int&gt;)</div>
<div class="line">        );</div>
<div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#a82e67ada9561f5e1176faab8eb94a064">lookup</a>(m, type&lt;float&gt;) == just(3.3));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="lookup.time.png" alt="lookup.time.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a234e4ee0bd5e0e9e604d6140fde24074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto in</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>([](<span class="keyword">auto</span>&amp;&amp; key, <span class="keyword">auto</span>&amp;&amp; searchable) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_searchable.html#a04e413e4acd1dac89e442df2f30f3e2d">elem</a>(</div>
<div class="line">            detail::std::forward&lt;decltype(searchable)&gt;(searchable),</div>
<div class="line">            detail::std::forward&lt;decltype(key)&gt;(key)</div>
<div class="line">        );</div>
<div class="line">    })</div>
</div><!-- fragment -->
<p>Return whether the key occurs in the structure. </p>
<p>Specifically, this is equivalent to <code>flip(elem)</code>, except that <code>in</code> can also be used in infix notation for increased expressiveness. This function is not a method that can be overriden; it is just a convenience function provided with the type class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchable</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable type class defines equality and inequality. ">Comparable</a></code> with the other keys of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gacf82d20cb2ab6efe5849fadae0a043a8">BOOST_HANA_CONSTEXPR_LAMBDA</a> <span class="keyword">auto</span> xs = tuple(</div>
<div class="line">            int_&lt;1&gt;, type&lt;int&gt;, int_&lt;2&gt;, type&lt;float&gt;, int_&lt;3&gt;, type&lt;void&gt;, type&lt;char&gt;</div>
<div class="line">        );</div>
<div class="line">        <a class="code" href="group__group-details.html#ga90927e0cc2d4f09fd9f7e17ecead6f77">BOOST_HANA_CONSTANT_ASSERT</a>(</div>
<div class="line">            filter(xs, <a class="code" href="structboost_1_1hana_1_1_searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a> ^ tuple(int_&lt;3&gt;, type&lt;int&gt;, type&lt;void&gt;))</div>
<div class="line">            ==</div>
<div class="line">            tuple(type&lt;int&gt;, int_&lt;3&gt;, type&lt;void&gt;)</div>
<div class="line">        );</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa713b34e28603ea39c8873609fd24801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto subset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> Searchable::instance&lt;</div>
<div class="line">            datatype_t&lt;decltype(xs)&gt;</div>
<div class="line">        &gt;::subset_impl(</div>
<div class="line">            detail::std::forward&lt;decltype(xs)&gt;(xs),</div>
<div class="line">            detail::std::forward&lt;decltype(ys)&gt;(ys)</div>
<div class="line">        );</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return whether a structure contains a subset of the keys of another structure. </p>
<p>Specifically, <code>subset(xs, ys)</code> is a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical type class is for data types acting like a boolean. ">Logical</a></code> representing whether all of the keys of <code>xs</code> are also keys of <code>ys</code>. In particular, this method does <em>not</em> check whether <code>xs</code> is a strict subset of <code>ys</code>, i.e. a subset that is not equal. Both arguments may have different data types, but only the data type of the first argument is used for method dispatching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to check whether it is a subset of <code>ys</code>.</td></tr>
    <tr><td class="paramname">ys</td><td>The structure to check whether it is a superset of <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line">        <a class="code" href="group__group-details.html#gaf87274a2e99e7f63831553535de99d89">BOOST_HANA_CONSTEXPR_ASSERT</a>(<a class="code" href="structboost_1_1hana_1_1_searchable.html#aa713b34e28603ea39c8873609fd24801">subset</a>(tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), tuple(3.3, 1, <span class="charliteral">&#39;2&#39;</span>, <span class="keyword">nullptr</span>)));</div>
</div><!-- fragment --> <h3>Benchmarks</h3>
<div class="image">
<img src="subset.time.png" alt="subset.time.png"/>
</div>
 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_searchable.html">Searchable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
