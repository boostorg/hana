<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::Sequence Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/implementation-defined/g, "implementation-defined".link("index.html#tutorial-glossary-implementation_defined").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Sequence.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Sequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Sequence Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> concept represents generic index-based sequences. </p>
<p>Compared to other abstract concepts, the <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> concept is very specific. It represents generic index-based sequences. The reason why such a specific concept is provided is because there are a lot of models that behave exactly the same while being implemented in wildly different ways. It is useful to regroup all those data types under the same umbrella for the purpose of generic programming.</p>
<p>In fact, models of this concept are not only <em>similar</em>. They are actually <em>isomorphic</em>, in a sense that we define below, which is a fancy way of rigorously saying that they behave exactly the same to an external observer.</p>
<h2>Minimal complete definition </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code>, <code>make</code>, and <code>models</code></p>
<p>The <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> concept does not provide basic methods that could be used as a minimal complete definition; instead, it borrows methods from other concepts and add laws to them. For this reason, it is necessary to specialize the <code>models_impl</code> metafunction in Hana's namespace to tell Hana that a type is indeed a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>. Explicitly specializing the <code>models_impl</code> metafunction can be seen like a seal saying "this data type satisfies the additional laws of a `Sequence`", since those can't be checked by Hana automatically.</p>
<h2>Laws </h2>
<p>The laws for being a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> are simple, and their goal is to restrict the semantics that can be associated to the functions provided by other concepts. First, a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> must be a finite <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code> (thus a <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> too). Secondly, for a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> tag <code>S</code>, <code>make&lt;S&gt;(x1, ..., xn)</code> must be an object of tag <code>S</code> and whose linearization is <code>[x1, ..., xn]</code>. This basically ensures that objects of tag <code>S</code> are equivalent to their linearization, and that they can be created from such a linearization (with <code>make</code>).</p>
<p>While it would be possible in theory to handle infinite sequences, doing so complicates the implementation of many algorithms. For simplicity, the current version of the library only handles finite sequences. However, note that this does not affect in any way the potential for having infinite <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s and <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>s.</p>
<h2>Refined concepts </h2>
<ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> (definition provided automatically)<br />
Two <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are equal if and only if they contain the same number of elements and their elements at any given index are equal. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::make_tuple(1, 2, 3) == hana::make_tuple(1, 2, 3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::make_tuple(1, 2, 3) != hana::make_tuple(1, 2, 3, 4));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code> (definition provided automatically)<br />
<code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are ordered using the traditional lexicographical ordering. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="less_8hpp.html">boost/hana/less.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::make_tuple(1, 2, 3) &lt; hana::make_tuple(2, 3, 4), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::make_tuple(1, 2, 3) &lt; hana::make_tuple(1, 2, 3, 4), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code> (definition provided automatically)<br />
<code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s implement <code>transform</code> as the mapping of a function over each element of the sequence. This is somewhat equivalent to what <code>std::transform</code> does to ranges of iterators. Also note that mapping a function over an empty sequence returns an empty sequence and never applies the function, as would be expected. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::transform(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>}), to_string) ==</div>
<div class="line">        hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> (definition provided automatically)<br />
First, <code>lift</code>ing a value into a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> is the same as creating a singleton sequence containing that value. Second, applying a sequence of functions to a sequence of values will apply each function to all the values in the sequence, and then return a list of all the results. In other words, <div class="fragment"><div class="line">ap([f1, ..., fN], [x1, ..., xM]) == [</div>
<div class="line">    f1(x1), ..., f1(xM),</div>
<div class="line">    ...</div>
<div class="line">    fN(x1), ..., fN(xM)</div>
<div class="line">]</div>
</div><!-- fragment --> Example: <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ap_8hpp.html">boost/hana/ap.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2tuple_8hpp.html">boost/hana/ext/std/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flip_8hpp.html">boost/hana/functional/flip.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lift_8hpp.html">boost/hana/lift.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::lift&lt;hana::Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>) == hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::equal(hana::lift&lt;hana::ext::std::Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>), std::make_tuple(<span class="charliteral">&#39;x&#39;</span>)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> f = hana::make_pair;</div>
<div class="line">constexpr <span class="keyword">auto</span> g = <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(hana::make_pair);</div>
<div class="line">static_assert(</div>
<div class="line">    hana::ap(hana::make_tuple(f, g), hana::make_tuple(1, 2, 3), hana::make_tuple(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>))</div>
<div class="line">        ==</div>
<div class="line">    hana::make_tuple(</div>
<div class="line">        f(1, <span class="charliteral">&#39;a&#39;</span>), f(1, <span class="charliteral">&#39;b&#39;</span>), f(2, <span class="charliteral">&#39;a&#39;</span>), f(2, <span class="charliteral">&#39;b&#39;</span>), f(3, <span class="charliteral">&#39;a&#39;</span>), f(3, <span class="charliteral">&#39;b&#39;</span>),</div>
<div class="line">        g(1, <span class="charliteral">&#39;a&#39;</span>), g(1, <span class="charliteral">&#39;b&#39;</span>), g(2, <span class="charliteral">&#39;a&#39;</span>), g(2, <span class="charliteral">&#39;b&#39;</span>), g(3, <span class="charliteral">&#39;a&#39;</span>), g(3, <span class="charliteral">&#39;b&#39;</span>)</div>
<div class="line">    )</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> (definition provided automatically)<br />
First, <code>flaten</code>ning a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> takes a sequence of sequences and concatenates them to get a larger sequence. In other words, <div class="fragment"><div class="line">flatten([[a1, ..., aN], ..., [z1, ..., zM]]) == [</div>
<div class="line">    a1, ..., aN, ..., z1, ..., zM</div>
<div class="line">]</div>
</div><!-- fragment --> This acts like a <code>std::tuple_cat</code> function, except it receives a sequence of sequences instead of a variadic pack of sequences to flatten.<br />
<b>Example</b>: <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flatten_8hpp.html">boost/hana/flatten.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::flatten(hana::make_tuple(</div>
<div class="line">        hana::make_tuple(1, 2),</div>
<div class="line">        hana::make_tuple(3, 4),</div>
<div class="line">        hana::make_tuple(hana::make_tuple(5, 6))</div>
<div class="line">    ))</div>
<div class="line">    == hana::make_tuple(1, 2, 3, 4, hana::make_tuple(5, 6))</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --></li>
</ol>
<p>Also note that the model of <code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s can be seen as modeling nondeterminism. A nondeterministic computation can be modeled as a function which returns a sequence of possible results. In this line of thought, <code>chain</code>ing a sequence of values into such a function will return a sequence of all the possible output values, i.e. a sequence of all the values applied to all the functions in the sequences.<br />
<b>Example</b>: </p><div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chain_8hpp.html">boost/hana/chain.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type__traits_8hpp.html">boost/hana/ext/std/type_traits.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">boost/hana/for_each.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Using the Tuple Monad, we generate all the possible combinations of</span></div>
<div class="line"><span class="comment">// cv-qualifiers and reference qualifiers. Then, we use the `optional`</span></div>
<div class="line"><span class="comment">// Monad to make sure that our generic function can be called with</span></div>
<div class="line"><span class="comment">// arguments of any of those types.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// cv_qualifiers : Type -&gt; Tuple(Type)</span></div>
<div class="line"><span class="keyword">auto</span> cv_qualifiers = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keywordflow">return</span> hana::make_tuple(</div>
<div class="line">        t,</div>
<div class="line">        hana::traits::add_const(t),</div>
<div class="line">        hana::traits::add_volatile(t),</div>
<div class="line">        hana::traits::add_volatile(hana::traits::add_const(t))</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// ref_qualifiers : Type -&gt; Tuple(Type)</span></div>
<div class="line"><span class="keyword">auto</span> ref_qualifiers = [](<span class="keyword">auto</span> t) {</div>
<div class="line">    <span class="keywordflow">return</span> hana::make_tuple(</div>
<div class="line">        hana::traits::add_lvalue_reference(t),</div>
<div class="line">        hana::traits::add_rvalue_reference(t)</div>
<div class="line">    );</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> possible_args = cv_qualifiers(hana::type_c&lt;int&gt;) | ref_qualifiers;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    possible_args == hana::make_tuple(</div>
<div class="line">                        hana::type_c&lt;int&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int&amp;&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int const&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int const&amp;&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int volatile&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int volatile&amp;&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int const volatile&amp;&gt;,</div>
<div class="line">                        hana::type_c&lt;int const volatile&amp;&amp;&gt;</div>
<div class="line">                    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>some_function {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(T&amp;&amp;)<span class="keyword"> const </span>{ }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    hana::for_each(possible_args, [](<span class="keyword">auto</span> t) {</div>
<div class="line">        <span class="keyword">using</span> T = <span class="keyword">typename</span> decltype(t)::type;</div>
<div class="line">        static_assert(decltype(hana::is_valid(some_function{})(std::declval&lt;T&gt;())){},</div>
<div class="line">        <span class="stringliteral">&quot;some_function should be callable with any type of argument&quot;</span>);</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><ol type="1">
<li><code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> (definition provided automatically)<br />
<code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s are models of the <code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> concept by considering the empty sequence as the unit of <code>concat</code>, and sequence concatenation as <code>concat</code>. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="append_8hpp.html">boost/hana/append.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concat_8hpp.html">boost/hana/concat.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="empty_8hpp.html">boost/hana/empty.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::empty&lt;hana::Tuple&gt;() == hana::make_tuple());</div>
<div class="line"></div>
<div class="line">static_assert(hana::append(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="keyword">nullptr</span>)</div>
<div class="line">                        == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="keyword">nullptr</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::concat(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::make_tuple(<span class="stringliteral">&quot;abcdef&quot;</span>s)) ==</div>
<div class="line">        hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abcdef&quot;</span>s)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code><br />
The model of <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s is uniquely determined by the model of <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code>. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold__left_8hpp.html">boost/hana/fold_left.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> show = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;(&quot;</span> + to_string(x) + <span class="stringliteral">&quot; + &quot;</span> + to_string(y) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::fold_left(hana::make_tuple(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>), <span class="stringliteral">&quot;1&quot;</span>, show) == <span class="stringliteral">&quot;(((1 + 2) + 3) + 4)&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code><br />
The model of <code><a class="el" href="structboost_1_1hana_1_1Iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a></code> for <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>s corresponds to iteration over each element of the sequence, in order. This model is not provided automatically, and it is in fact part of the minimal complete definition for the <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> concept. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="front_8hpp.html">boost/hana/front.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__empty_8hpp.html">boost/hana/is_empty.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tail_8hpp.html">boost/hana/tail.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::front(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::tail(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == hana::make_tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::is_empty(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::is_empty(hana::make_tuple()));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> (definition provided automatically)<br />
Searching through a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> is equivalent to just searching through a list of the values it contains. The keys and the values on which the search is performed are both the elements of the sequence. <div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="contains_8hpp.html">boost/hana/contains.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2is__a_8hpp.html">boost/hana/core/is_a.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find__if_8hpp.html">boost/hana/find_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::string_literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::find_if(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abc&quot;</span>s), hana::is_a&lt;std::string&gt;) == hana::just(<span class="stringliteral">&quot;abc&quot;</span>s)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        <span class="stringliteral">&quot;abc&quot;</span>s ^hana::in^ hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="stringliteral">&quot;abc&quot;</span>s)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code> </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:a211a6ce41e4972cd7642b77a1afa8e95"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a211a6ce41e4972cd7642b77a1afa8e95">cartesian_product</a></td></tr>
<tr class="memdesc:a211a6ce41e4972cd7642b77a1afa8e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cartesian product of a sequence of sequences.  <a href="#a211a6ce41e4972cd7642b77a1afa8e95">More...</a><br /></td></tr>
<tr class="separator:a211a6ce41e4972cd7642b77a1afa8e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee87c07664e57a8ffbfdceed39265ef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#aaee87c07664e57a8ffbfdceed39265ef">drop_back</a></td></tr>
<tr class="memdesc:aaee87c07664e57a8ffbfdceed39265ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the last <code>n</code> elements of a finite sequence, and return the rest.  <a href="#aaee87c07664e57a8ffbfdceed39265ef">More...</a><br /></td></tr>
<tr class="separator:aaee87c07664e57a8ffbfdceed39265ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a></td></tr>
<tr class="memdesc:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structboost_1_1hana_1_1Group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> adjacent elements of a sequence that all respect a binary predicate, by default equality.  <a href="#a83d9b8f0f293c6fe7cfccd2359dec330">More...</a><br /></td></tr>
<tr class="separator:a83d9b8f0f293c6fe7cfccd2359dec330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791e6dc0e27d8e3a113e4d94482550f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a5791e6dc0e27d8e3a113e4d94482550f">insert</a></td></tr>
<tr class="memdesc:a5791e6dc0e27d8e3a113e4d94482550f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value at a given index in a sequence.  <a href="#a5791e6dc0e27d8e3a113e4d94482550f">More...</a><br /></td></tr>
<tr class="separator:a5791e6dc0e27d8e3a113e4d94482550f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c12b49d0683af43f766a0093e413cea"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a3c12b49d0683af43f766a0093e413cea">insert_range</a></td></tr>
<tr class="memdesc:a3c12b49d0683af43f766a0093e413cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert several values at a given index in a sequence.  <a href="#a3c12b49d0683af43f766a0093e413cea">More...</a><br /></td></tr>
<tr class="separator:a3c12b49d0683af43f766a0093e413cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#ab6e88c5dd3f638a60c0a451ad6db95ec">intersperse</a></td></tr>
<tr class="memdesc:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a value between each pair of elements in a finite sequence.  <a href="#ab6e88c5dd3f638a60c0a451ad6db95ec">More...</a><br /></td></tr>
<tr class="separator:ab6e88c5dd3f638a60c0a451ad6db95ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b65dd69bb016d647801718e840816"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a></td></tr>
<tr class="memdesc:a788b65dd69bb016d647801718e840816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a sequence based on a <code>predicate</code>.  <a href="#a788b65dd69bb016d647801718e840816">More...</a><br /></td></tr>
<tr class="separator:a788b65dd69bb016d647801718e840816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a45ec7767d19eb7eaabb71ead3796a7f1">permutations</a></td></tr>
<tr class="memdesc:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sequence of all the permutations of the given sequence.  <a href="#a45ec7767d19eb7eaabb71ead3796a7f1">More...</a><br /></td></tr>
<tr class="separator:a45ec7767d19eb7eaabb71ead3796a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65295edabe2029007e7ecf640ae7bb0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a65295edabe2029007e7ecf640ae7bb0b">remove_at</a></td></tr>
<tr class="memdesc:a65295edabe2029007e7ecf640ae7bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element at a given index from a sequence.  <a href="#a65295edabe2029007e7ecf640ae7bb0b">More...</a><br /></td></tr>
<tr class="separator:a65295edabe2029007e7ecf640ae7bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597b243b348503860e1179065c508ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:aa597b243b348503860e1179065c508ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#aa597b243b348503860e1179065c508ec">remove_at_c</a></td></tr>
<tr class="memdesc:aa597b243b348503860e1179065c508ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>remove_at</code>; provided for convenience.  <a href="#aa597b243b348503860e1179065c508ec">More...</a><br /></td></tr>
<tr class="separator:aa597b243b348503860e1179065c508ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b84e0e0a256620d98ed5062b456c96"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#aa1b84e0e0a256620d98ed5062b456c96">remove_range</a></td></tr>
<tr class="memdesc:aa1b84e0e0a256620d98ed5062b456c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the elements inside a given range of indices from a sequence.  <a href="#aa1b84e0e0a256620d98ed5062b456c96">More...</a><br /></td></tr>
<tr class="separator:aa1b84e0e0a256620d98ed5062b456c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53da1ba4620bb48ef50cbc1d7812131"><td class="memTemplParams" colspan="2">template&lt;std::size_t from, std::size_t to&gt; </td></tr>
<tr class="memitem:af53da1ba4620bb48ef50cbc1d7812131"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#af53da1ba4620bb48ef50cbc1d7812131">remove_range_c</a></td></tr>
<tr class="memdesc:af53da1ba4620bb48ef50cbc1d7812131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>remove_range</code>; provided for convenience.  <a href="#af53da1ba4620bb48ef50cbc1d7812131">More...</a><br /></td></tr>
<tr class="separator:af53da1ba4620bb48ef50cbc1d7812131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4471413ccc3835db5e48658683b8aba0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a4471413ccc3835db5e48658683b8aba0">reverse</a></td></tr>
<tr class="memdesc:a4471413ccc3835db5e48658683b8aba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a sequence.  <a href="#a4471413ccc3835db5e48658683b8aba0">More...</a><br /></td></tr>
<tr class="separator:a4471413ccc3835db5e48658683b8aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a82d04d19ba3ce7dcb6aaef0dbd0423"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a8a82d04d19ba3ce7dcb6aaef0dbd0423">scan_left</a></td></tr>
<tr class="memdesc:a8a82d04d19ba3ce7dcb6aaef0dbd0423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> to the left and return a list containing the successive reduction states.  <a href="#a8a82d04d19ba3ce7dcb6aaef0dbd0423">More...</a><br /></td></tr>
<tr class="separator:a8a82d04d19ba3ce7dcb6aaef0dbd0423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdf082af400671e43a4035e14ae7f82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a4fdf082af400671e43a4035e14ae7f82">scan_right</a></td></tr>
<tr class="memdesc:a4fdf082af400671e43a4035e14ae7f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> to the right and return a list containing the successive reduction states.  <a href="#a4fdf082af400671e43a4035e14ae7f82">More...</a><br /></td></tr>
<tr class="separator:a4fdf082af400671e43a4035e14ae7f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18968c488a8b0cdc2697296024da9293"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a18968c488a8b0cdc2697296024da9293">slice</a></td></tr>
<tr class="memdesc:a18968c488a8b0cdc2697296024da9293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a subsequence delimited by the given indices.  <a href="#a18968c488a8b0cdc2697296024da9293">More...</a><br /></td></tr>
<tr class="separator:a18968c488a8b0cdc2697296024da9293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplParams" colspan="2">template&lt;std::size_t from, std::size_t to&gt; </td></tr>
<tr class="memitem:afa204f71aac9f461d8574653295c67ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#afa204f71aac9f461d8574653295c67ba">slice_c</a></td></tr>
<tr class="memdesc:afa204f71aac9f461d8574653295c67ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>slice</code>; provided for convenience.  <a href="#afa204f71aac9f461d8574653295c67ba">More...</a><br /></td></tr>
<tr class="separator:afa204f71aac9f461d8574653295c67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c1454689bf6d2264bc428dc1d039db"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a></td></tr>
<tr class="memdesc:a58c1454689bf6d2264bc428dc1d039db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a sequence, optionally based on a custom <code>predicate</code>.  <a href="#a58c1454689bf6d2264bc428dc1d039db">More...</a><br /></td></tr>
<tr class="separator:a58c1454689bf6d2264bc428dc1d039db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663fc84c23656a41d4dfcb586f0085c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a></td></tr>
<tr class="memdesc:ab663fc84c23656a41d4dfcb586f0085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence.  <a href="#ab663fc84c23656a41d4dfcb586f0085c">More...</a><br /></td></tr>
<tr class="separator:ab663fc84c23656a41d4dfcb586f0085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b5d2d363fb5e2d444e8bfe6bc712c7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a65b5d2d363fb5e2d444e8bfe6bc712c7">subsequence</a></td></tr>
<tr class="memdesc:a65b5d2d363fb5e2d444e8bfe6bc712c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements at the given indices of a sequence.  <a href="#a65b5d2d363fb5e2d444e8bfe6bc712c7">More...</a><br /></td></tr>
<tr class="separator:a65b5d2d363fb5e2d444e8bfe6bc712c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c20028c5115dcf38063d322f27b4ee1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a2c20028c5115dcf38063d322f27b4ee1">take</a></td></tr>
<tr class="memdesc:a2c20028c5115dcf38063d322f27b4ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first <code>n</code> elements of a sequence, or the whole sequence if the sequence has less than <code>n</code> elements.  <a href="#a2c20028c5115dcf38063d322f27b4ee1">More...</a><br /></td></tr>
<tr class="separator:a2c20028c5115dcf38063d322f27b4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:a63f9ab281c8e979adfd7f6678383c46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a63f9ab281c8e979adfd7f6678383c46b">take_c</a></td></tr>
<tr class="memdesc:a63f9ab281c8e979adfd7f6678383c46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>take</code>; provided for convenience.  <a href="#a63f9ab281c8e979adfd7f6678383c46b">More...</a><br /></td></tr>
<tr class="separator:a63f9ab281c8e979adfd7f6678383c46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86916c5c62a42f01f85450b366ef6eff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a></td></tr>
<tr class="memdesc:a86916c5c62a42f01f85450b366ef6eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take elements from a sequence while the <code>predicate</code> is satisfied.  <a href="#a86916c5c62a42f01f85450b366ef6eff">More...</a><br /></td></tr>
<tr class="separator:a86916c5c62a42f01f85450b366ef6eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435bb610ac90db4df48bd3fce876b8a2"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a435bb610ac90db4df48bd3fce876b8a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a435bb610ac90db4df48bd3fce876b8a2">unfold_left</a></td></tr>
<tr class="memdesc:a435bb610ac90db4df48bd3fce876b8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual operation to <code>fold_left</code> for sequences.  <a href="#a435bb610ac90db4df48bd3fce876b8a2">More...</a><br /></td></tr>
<tr class="separator:a435bb610ac90db4df48bd3fce876b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd815736023ac04d4cb8f99c4c490442"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:acd815736023ac04d4cb8f99c4c490442"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#acd815736023ac04d4cb8f99c4c490442">unfold_right</a></td></tr>
<tr class="memdesc:acd815736023ac04d4cb8f99c4c490442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual operation to <code>fold_right</code> for sequences.  <a href="#acd815736023ac04d4cb8f99c4c490442">More...</a><br /></td></tr>
<tr class="separator:acd815736023ac04d4cb8f99c4c490442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c9ad102df93f8e88c37afd92f34590"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a00c9ad102df93f8e88c37afd92f34590">unique</a></td></tr>
<tr class="memdesc:a00c9ad102df93f8e88c37afd92f34590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all consecutive duplicate elements from a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>.  <a href="#a00c9ad102df93f8e88c37afd92f34590">More...</a><br /></td></tr>
<tr class="separator:a00c9ad102df93f8e88c37afd92f34590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a23b6ac9e78577d70b9108a80e6b1534c">zip</a></td></tr>
<tr class="memdesc:a23b6ac9e78577d70b9108a80e6b1534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one sequence or more.  <a href="#a23b6ac9e78577d70b9108a80e6b1534c">More...</a><br /></td></tr>
<tr class="separator:a23b6ac9e78577d70b9108a80e6b1534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f6d2040b9c9f2aea6a334e41c89ac7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a10f6d2040b9c9f2aea6a334e41c89ac7">zip_shortest</a></td></tr>
<tr class="memdesc:a10f6d2040b9c9f2aea6a334e41c89ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one sequence or more.  <a href="#a10f6d2040b9c9f2aea6a334e41c89ac7">More...</a><br /></td></tr>
<tr class="separator:a10f6d2040b9c9f2aea6a334e41c89ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef70e8791ace2fafabf0ff3adaa8630c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#aef70e8791ace2fafabf0ff3adaa8630c">zip_shortest_with</a></td></tr>
<tr class="memdesc:aef70e8791ace2fafabf0ff3adaa8630c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one sequence or more with a given function.  <a href="#aef70e8791ace2fafabf0ff3adaa8630c">More...</a><br /></td></tr>
<tr class="separator:aef70e8791ace2fafabf0ff3adaa8630c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Sequence.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a></td></tr>
<tr class="memdesc:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zip one sequence or more with a given function.  <a href="#a5eadaf63535ebb8cdd8d9e4c16b9bacd">More...</a><br /></td></tr>
<tr class="separator:a5eadaf63535ebb8cdd8d9e4c16b9bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="a211a6ce41e4972cd7642b77a1afa8e95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cartesian_product</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Computes the cartesian product of a sequence of sequences. </p>
<p>Given a sequence of sequences, <code>cartesian_product</code> returns a new sequence of sequences containing the cartesian product of the original sequences. For this method to finish, a finite number of finite sequences must be provided.</p>
<p>All the sequences must have the same data type, and that data type must also match that of the top-level sequence. In other words, the sequence must be of the form </p><div class="fragment"><div class="line">make_sequence(</div>
<div class="line">    make_sequence(...),</div>
<div class="line">    ...</div>
<div class="line">    make_sequence(...)</div>
<div class="line">)</div>
</div><!-- fragment --><p>for some function <code>make_sequence</code> returning a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code>.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S(T)</code>, the signature is </p><p class="formulaDsp">
\[ \mathtt{cartesian\_product} : S(S(T)) \to S(S(T)) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A sequence of sequences of which the cartesian product is computed.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cartesian__product_8hpp.html">boost/hana/cartesian_product.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> tuples = hana::make_tuple(</div>
<div class="line">    hana::make_tuple(1, 2, 3),</div>
<div class="line">    hana::make_tuple(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>),</div>
<div class="line">    hana::make_tuple(hana::type_c&lt;int&gt;, hana::type_c&lt;char&gt;)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> prod = hana::make_tuple(</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>, hana::type_c&lt;int&gt;),</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>, hana::type_c&lt;char&gt;),</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;b&#39;</span>, hana::type_c&lt;int&gt;),</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;b&#39;</span>, hana::type_c&lt;char&gt;),</div>
<div class="line"></div>
<div class="line">    hana::make_tuple(2, <span class="charliteral">&#39;a&#39;</span>, hana::type_c&lt;int&gt;),</div>
<div class="line">    hana::make_tuple(2, <span class="charliteral">&#39;a&#39;</span>, hana::type_c&lt;char&gt;),</div>
<div class="line">    hana::make_tuple(2, <span class="charliteral">&#39;b&#39;</span>, hana::type_c&lt;int&gt;),</div>
<div class="line">    hana::make_tuple(2, <span class="charliteral">&#39;b&#39;</span>, hana::type_c&lt;char&gt;),</div>
<div class="line"></div>
<div class="line">    hana::make_tuple(3, <span class="charliteral">&#39;a&#39;</span>, hana::type_c&lt;int&gt;),</div>
<div class="line">    hana::make_tuple(3, <span class="charliteral">&#39;a&#39;</span>, hana::type_c&lt;char&gt;),</div>
<div class="line">    hana::make_tuple(3, <span class="charliteral">&#39;b&#39;</span>, hana::type_c&lt;int&gt;),</div>
<div class="line">    hana::make_tuple(3, <span class="charliteral">&#39;b&#39;</span>, hana::type_c&lt;char&gt;)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">static_assert(hana::cartesian_product(tuples) == prod, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.cartesian_product.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="aaee87c07664e57a8ffbfdceed39265ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto drop_back</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; n]) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Drop the last <code>n</code> elements of a finite sequence, and return the rest. </p>
<p>Given a finite <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>xs</code> with a linearization of <code>[x1, ..., xm]</code> and a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>n</code> holding an unsigned integral value, <code>drop_back(xs, n)</code> is a sequence with the same tag as <code>xs</code> whose linearization is <code>[x1, ..., xm-n]</code>. If <code>n</code> is not given, it defaults to a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> with an unsigned integral value equal to <code>1</code>.</p>
<p>In case <code>length(xs) &lt;= n</code>, <code>drop_back</code> will simply drop the whole sequence without failing, thus returning an empty sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence from which elements are dropped.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding an unsigned integral value representing the number of elements to be dropped from the end of the sequence. If <code>n</code> is not given, it defaults to a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> with an unsigned integral value equal to <code>1</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="drop__back_8hpp.html">boost/hana/drop_back.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 2.0);</div>
<div class="line"></div>
<div class="line">static_assert(hana::drop_back(xs, hana::size_t&lt;0&gt;) == xs, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::drop_back(xs, hana::size_t&lt;1&gt;) == hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::drop_back(xs, hana::size_t&lt;2&gt;) == hana::make_tuple(0), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::drop_back(xs, hana::size_t&lt;3&gt;) == hana::make_tuple());</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::drop_back(xs, hana::size_t&lt;4&gt;) == hana::make_tuple());</div>
<div class="line"></div>
<div class="line">static_assert(hana::drop_back(xs) == hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a83d9b8f0f293c6fe7cfccd2359dec330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto group</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><a class="el" href="structboost_1_1hana_1_1Group.html" title="The Group concept represents Monoids where all objects have an inverse w.r.t. the Monoid&#39;s binary ope...">Group</a> adjacent elements of a sequence that all respect a binary predicate, by default equality. </p>
<p>Given a <em>finite</em> <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> and an optional predicate (by default <code>equal</code>), <code>group</code> returns a sequence of subsequences representing groups of adjacent elements that are "equal" with respect to the predicate. In other words, the groups are such that the predicate is satisfied when it is applied to any two adjacent elements in that group. The sequence returned by <code>group</code> is such that the concatenation of its elements is equal to the original sequence, which is equivalent to saying that the order of the elements is not changed.</p>
<p>If no predicate is provided, adjacent elements in the sequence must all be compile-time <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> <code>s</code> of data type <code>S(T)</code>, a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code> and a predicate \( pred : T \times T \to Bool \), <code>group</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathtt{group} : S(T) \times (T \times T \to Bool) \to S(S(T)) \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a>. The signature is then </p><p class="formulaDsp">
\[ \mathtt{group} : S(T) \to S(S(T)) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to split into groups.</td></tr>
    <tr><td class="paramname">predicate</td><td>A binary function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are <em>adjacent</em> elements in the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether both elements should be in the same group (subsequence) of the result. The result returned by <code>predicate</code> must be a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. Also, <code>predicate</code> has to define an equivalence relation as defined by the <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> concept. When this predicate is not provided, it defaults to <code>equal</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>group.by</code>) </h2>
<p><code>group</code> can be called in a third way, which provides a nice syntax especially when working with the <code>comparing</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a83d9b8f0f293c6fe7cfccd2359dec330">group</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>group(-, predicate)</code> denotes the partial application of <code>group</code> to <code>predicate</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="comparing_8hpp.html">boost/hana/comparing.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="group_8hpp.html">boost/hana/group.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// group without a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::group(hana::make_tuple(hana::int_&lt;1&gt;, hana::long_&lt;1&gt;, hana::type_c&lt;int&gt;, hana::char_&lt;&#39;x&#39;&gt;, hana::char_&lt;&#39;x&#39;&gt;))</div>
<div class="line">        == hana::make_tuple(</div>
<div class="line">            hana::make_tuple(hana::int_&lt;1&gt;, hana::long_&lt;1&gt;),</div>
<div class="line">            hana::make_tuple(hana::type_c&lt;int&gt;),</div>
<div class="line">            hana::make_tuple(hana::char_&lt;&#39;x&#39;&gt;, hana::char_&lt;&#39;x&#39;&gt;)</div>
<div class="line">        )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// group with a predicate</span></div>
<div class="line">constexpr <span class="keyword">auto</span> tuples = hana::make_tuple(</div>
<div class="line">    hana::range_c&lt;int, 0, 1&gt;,</div>
<div class="line">    hana::range_c&lt;int, 0, 2&gt;,</div>
<div class="line">    hana::range_c&lt;int, 1, 3&gt;,</div>
<div class="line">    hana::range_c&lt;int, 2, 6&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::group(tuples, hana::comparing(hana::length))</div>
<div class="line">        == hana::make_tuple(</div>
<div class="line">            hana::make_tuple(</div>
<div class="line">                hana::range_c&lt;int, 0, 1&gt;</div>
<div class="line">            ),</div>
<div class="line">            hana::make_tuple(</div>
<div class="line">                hana::range_c&lt;int, 0, 2&gt;,</div>
<div class="line">                hana::range_c&lt;int, 1, 3&gt;</div>
<div class="line">            ),</div>
<div class="line">            hana::make_tuple(</div>
<div class="line">                hana::range_c&lt;int, 2, 6&gt;</div>
<div class="line">            )</div>
<div class="line">        )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// group.by is syntactic sugar</span></div>
<div class="line">static_assert(</div>
<div class="line">    hana::group.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::comparing(hana::decltype_),</div>
<div class="line">                   hana::make_tuple(1, 2, 3, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, 4.4, 5.5))</div>
<div class="line">        == hana::make_tuple(</div>
<div class="line">            hana::make_tuple(1, 2, 3),</div>
<div class="line">            hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>),</div>
<div class="line">            hana::make_tuple(4.4, 5.5)</div>
<div class="line">        )</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5791e6dc0e27d8e3a113e4d94482550f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto insert</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; element) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Insert a value at a given index in a sequence. </p>
<p>Given a sequence, an index and an element to insert, <code>insert</code> inserts the element at the given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence in which a value should be inserted.</td></tr>
    <tr><td class="paramname">n</td><td>The index at which an element should be inserted. This must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an integral type, and it must also be true that <code>n &lt; length(xs)</code> if <code>xs</code> is a finite sequence.</td></tr>
    <tr><td class="paramname">element</td><td>The element to insert in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="insert_8hpp.html">boost/hana/insert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> xs = hana::make_tuple(<span class="stringliteral">&quot;Hello&quot;</span>s, <span class="stringliteral">&quot;world!&quot;</span>s);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::insert(xs, 1_c, <span class="stringliteral">&quot; &quot;</span>s) == hana::make_tuple(<span class="stringliteral">&quot;Hello&quot;</span>s, <span class="stringliteral">&quot; &quot;</span>s, <span class="stringliteral">&quot;world!&quot;</span>s)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3c12b49d0683af43f766a0093e413cea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto insert_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; elements) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Insert several values at a given index in a sequence. </p>
<p>Given a sequence, an index and any <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> containing elements to insert, <code>insert_range</code> inserts the elements in the <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> at the given index of the sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence in which values should be inserted.</td></tr>
    <tr><td class="paramname">n</td><td>The index at which elements should be inserted. This must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an integral type, and it must also be true that <code>n &lt; length(xs)</code> if <code>xs</code> is a finite sequence.</td></tr>
    <tr><td class="paramname">elements</td><td>A <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> containing elements to insert in the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="insert__range_8hpp.html">boost/hana/insert_range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> xs = hana::make_tuple(<span class="stringliteral">&quot;Hello&quot;</span>s, <span class="stringliteral">&quot;world!&quot;</span>s);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::insert_range(xs, 1_c, hana::make_tuple(1, 2, 3)) == hana::make_tuple(<span class="stringliteral">&quot;Hello&quot;</span>s, 1, 2, 3, <span class="stringliteral">&quot;world!&quot;</span>s)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab6e88c5dd3f638a60c0a451ad6db95ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto intersperse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; z) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Insert a value between each pair of elements in a finite sequence. </p>
<p>Given a finite <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>xs</code> with a linearization of <code>[x1, x2, ..., xn]</code>, <code>intersperse(xs, z)</code> is a new sequence with a linearization of <code>[x1, z, x2, z, x3, ..., xn-1, z, xn]</code>. In other words, it inserts the <code>z</code> element between every pair of elements of the original sequence. If the sequence is empty or has a single element, <code>intersperse</code> returns the sequence as-is. In all cases, the sequence must be finite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence in which a value is interspersed.</td></tr>
    <tr><td class="paramname">z</td><td>The value to be inserted between every pair of elements of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="intersperse_8hpp.html">boost/hana/intersperse.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::intersperse(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="charliteral">&#39;x&#39;</span>) == hana::make_tuple(1, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::intersperse(hana::make_tuple(), <span class="charliteral">&#39;x&#39;</span>) == hana::make_tuple());</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a788b65dd69bb016d647801718e840816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Partition a sequence based on a <code>predicate</code>. </p>
<p>Specifically, returns an unspecified <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> whose first element is a sequence of the elements satisfying the predicate, and whose second element is a sequence of the elements that do not satisfy the predicate.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> <code>S(T)</code>, a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code> and a predicate \( T \to Bool \), <code>partition</code> has the following signature: </p><p class="formulaDsp">
\[ \mathtt{partition} : S(T) \times (T \to Bool) \to S(T) \times S(T) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to be partitioned.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for each element <code>x</code> in the sequence and returning a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. If the result of <code>predicate</code> is true, then <code>x</code> is added to the sequence in the first component of the resulting <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>. Otherwise, <code>x</code> is added to the sequence in the second component.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>partition.by</code>) </h2>
<p><code>partition</code> can be called in an alternate way, which provides a nice syntax in some cases where the predicate is short: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a788b65dd69bb016d647801718e840816">partition</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>partition(-, predicate)</code> denotes the partial application of <code>partition</code> to <code>predicate</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partition_8hpp.html">boost/hana/partition.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rem_8hpp.html">boost/hana/rem.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::partition(hana::tuple_c&lt;int, 1, 2, 3, 4, 5, 6, 7&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x % hana::int_&lt;2&gt; != hana::int_&lt;0&gt;;</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(</div>
<div class="line">        hana::tuple_c&lt;int, 1, 3, 5, 7&gt;,</div>
<div class="line">        hana::tuple_c&lt;int, 2, 4, 6&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::partition(hana::tuple_t&lt;void, int, float, char, double&gt;, hana::trait&lt;std::is_floating_point&gt;)</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(</div>
<div class="line">        hana::tuple_t&lt;float, double&gt;,</div>
<div class="line">        hana::tuple_t&lt;void, int, char&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// partition.by is syntactic sugar</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::partition.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::trait&lt;std::is_floating_point&gt;,</div>
<div class="line">                       hana::tuple_t&lt;void, int, float, char, double&gt;)</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(</div>
<div class="line">        hana::tuple_t&lt;float, double&gt;,</div>
<div class="line">        hana::tuple_t&lt;void, int, char&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.partition.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a45ec7767d19eb7eaabb71ead3796a7f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto permutations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return a sequence of all the permutations of the given sequence. </p>
<p>Specifically, <code>permutations(xs)</code> is a sequence whose elements are permutations of the original sequence <code>xs</code>. The permutations are not guaranteed to be in any specific order. Also note that the number of permutations grows very rapidly as the length of the original sequence increases. The growth rate is <code>O(length(xs)!)</code>; with a sequence <code>xs</code> of length only 8, <code>permutations(xs)</code> contains over 40 000 elements!</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all__of_8hpp.html">boost/hana/all_of.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="contains_8hpp.html">boost/hana/contains.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="curry_8hpp.html">boost/hana/functional/curry.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="permutations_8hpp.html">boost/hana/permutations.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_permutation_of = hana::curry&lt;2&gt;([](<span class="keyword">auto</span> xs, <span class="keyword">auto</span> perm) {</div>
<div class="line">    <span class="keywordflow">return</span> hana::contains(hana::permutations(xs), perm);</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::all_of(</div>
<div class="line">            hana::make_tuple(</div>
<div class="line">                hana::make_tuple(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0),</div>
<div class="line">                hana::make_tuple(<span class="charliteral">&#39;1&#39;</span>, 3.0, 2),</div>
<div class="line">                hana::make_tuple(2, <span class="charliteral">&#39;1&#39;</span>, 3.0),</div>
<div class="line">                hana::make_tuple(2, 3.0, <span class="charliteral">&#39;1&#39;</span>),</div>
<div class="line">                hana::make_tuple(3.0, <span class="charliteral">&#39;1&#39;</span>, 2),</div>
<div class="line">                hana::make_tuple(3.0, 2, <span class="charliteral">&#39;1&#39;</span>)</div>
<div class="line">            ),</div>
<div class="line">            is_permutation_of(hana::make_tuple(<span class="charliteral">&#39;1&#39;</span>, 2, 3.0))</div>
<div class="line">        )</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a65295edabe2029007e7ecf640ae7bb0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_at</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; n) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the element at a given index from a sequence. </p>
<p><code>remove_at</code> returns a new sequence identical to the original, except that the element at the given index is removed. Specifically, <code>remove_at([x0, ..., xn-1, xn, xn+1, ..., xm], n)</code> is a new sequence equivalent to <code>[x0, ..., xn-1, xn+1, ..., xm]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if the index is out of the bounds of the sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A sequence from which an element is to be removed.</td></tr>
    <tr><td class="paramname">n</td><td>An non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the index of the element to be removed from the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="remove__at_8hpp.html">boost/hana/remove_at.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u);</div>
<div class="line"></div>
<div class="line">static_assert(hana::remove_at(xs, hana::size_t&lt;2&gt;) == hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 3u), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa597b243b348503860e1179065c508ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_at_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::remove_at(forwarded(xs), hana::size_t&lt;n&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>remove_at</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="remove__at_8hpp.html">boost/hana/remove_at.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u);</div>
<div class="line"></div>
<div class="line">static_assert(hana::remove_at_c&lt;2&gt;(xs) == hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 3u), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa1b84e0e0a256620d98ed5062b456c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; from, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove the elements inside a given range of indices from a sequence. </p>
<p><code>remove_range</code> returns a new sequence identical to the original, except that elements at indices in the provided range are removed. Specifically, <code>remove_range([x0, ..., xn], from, to)</code> is a new sequence equivalent to <code>[x0, ..., x_from-1, x_to, ..., xn]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior is undefined if the range contains any index out of the bounds of the sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A sequence from which elements are removed.</td></tr>
    <tr><td class="paramname">[from,to)</td><td>An half-open interval of <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s holding unsigned integral values, and representing the indices of the elements to be removed from the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="remove__range_8hpp.html">boost/hana/remove_range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u, 4, 5.5);</div>
<div class="line"></div>
<div class="line">static_assert(hana::remove_range(xs, hana::size_t&lt;2&gt;, hana::size_t&lt;4&gt;) == hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 4, 5.5), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af53da1ba4620bb48ef50cbc1d7812131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t from, std::size_t to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_range_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::remove_range(forwarded(xs), hana::size_t&lt;from&gt;, hana::size_t&lt;to&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>remove_range</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="remove__range_8hpp.html">boost/hana/remove_range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 2.2, 3u, 4, 5.5);</div>
<div class="line"></div>
<div class="line">static_assert(hana::remove_range_c&lt;2, 4&gt;(xs) == hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 4, 5.5), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4471413ccc3835db5e48658683b8aba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto reverse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Reverse a sequence. </p>
<p>Specifically, <code>reverse(xs)</code> is a new sequence containing the same elements as <code>xs</code>, except in reverse order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to reverse.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reverse_8hpp.html">boost/hana/reverse.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::reverse(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == hana::make_tuple(3.3, <span class="charliteral">&#39;2&#39;</span>, 1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8a82d04d19ba3ce7dcb6aaef0dbd0423"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scan_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Fold a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> to the left and return a list containing the successive reduction states. </p>
<p>Like <code>fold_left</code>, <code>scan_left</code> reduces a sequence to a single value using a binary operation. However, unlike <code>fold_left</code>, it builds up a sequence of the intermediary results computed along the way and returns that instead of only the final reduction state. Like <code>fold_left</code>, <code>scan_left</code> can be used with or without an initial reduction state.</p>
<p>When the sequence is empty, two things may arise. If an initial state was provided, a singleton list containing that state is returned. Otherwise, if no initial state was provided, an empty list is returned. In particular, unlike for <code>fold_left</code>, using <code>scan_left</code> on an empty sequence without an initial state is not an error.</p>
<p>More specifically, <code>scan_left([x1, ..., xn], state, f)</code> is a sequence whose <code>i</code>th element is equivalent to <code>fold_left([x1, ..., xi], state, f)</code>. The no-state variant is handled in an analogous way. For illustration, consider this left fold on a short sequence: </p><div class="fragment"><div class="line">fold_left([x1, x2, x3], state, f) == f(f(f(state, x1), x2), x3)</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan_left</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a8a82d04d19ba3ce7dcb6aaef0dbd0423">scan_left</a>([x1, x2, x3], state, f) == [</div>
<div class="line">    state,</div>
<div class="line">    f(state, x1),</div>
<div class="line">    f(f(state, x1), x2),</div>
<div class="line">    f(f(f(state, x1), x2), x3)</div>
<div class="line">]</div>
</div><!-- fragment --><p>Similarly, consider this left fold (without an initial state) on a short sequence: </p><div class="fragment"><div class="line">fold_left([x1, x2, x3, x4], f) == f(f(f(x1, x2), x3), x4)</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan_left</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a8a82d04d19ba3ce7dcb6aaef0dbd0423">scan_left</a>([x1, x2, x3, x4], f) == [</div>
<div class="line">    x1,</div>
<div class="line">    f(x1, x2),</div>
<div class="line">    f(f(x1, x2), x3),</div>
<div class="line">    f(f(f(x1, x2), x3), x4)</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to scan from the left.</td></tr>
    <tr><td class="paramname">state</td><td>The (optional) initial reduction state.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence. If no initial state is provided, <code>f</code> is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are both elements of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan__left_8hpp.html">boost/hana/scan_left.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> state, <span class="keyword">auto</span> element) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(state) + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// with initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::scan_left(hana::make_tuple(2, <span class="stringliteral">&quot;3&quot;</span>, <span class="charliteral">&#39;4&#39;</span>), 1, f) == hana::make_tuple(</div>
<div class="line">        1,</div>
<div class="line">        <span class="stringliteral">&quot;f(1, 2)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;f(f(1, 2), 3)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(1, 2), 3), 4)&quot;</span></div>
<div class="line">    ));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// without initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::scan_left(hana::make_tuple(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), f) == hana::make_tuple(</div>
<div class="line">        1,</div>
<div class="line">        <span class="stringliteral">&quot;f(1, 2)&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;f(f(1, 2), 3)&quot;</span></div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4fdf082af400671e43a4035e14ae7f82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto scan_right</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Fold a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> to the right and return a list containing the successive reduction states. </p>
<p>Like <code>fold_right</code>, <code>scan_right</code> reduces a sequence to a single value using a binary operation. However, unlike <code>fold_right</code>, it builds up a sequence of the intermediary results computed along the way and returns that instead of only the final reduction state. Like <code>fold_right</code>, <code>scan_right</code> can be used with or without an initial reduction state.</p>
<p>When the sequence is empty, two things may arise. If an initial state was provided, a singleton list containing that state is returned. Otherwise, if no initial state was provided, an empty list is returned. In particular, unlike for <code>fold_right</code>, using <code>scan_right</code> on an empty sequence without an initial state is not an error.</p>
<p>More specifically, <code>scan_right([x1, ..., xn], state, f)</code> is a sequence whose <code>i</code>th element is equivalent to <code>fold_right([x1, ..., xi], state, f)</code>. The no-state variant is handled in an analogous way. For illustration, consider this right fold on a short sequence: </p><div class="fragment"><div class="line">fold_right([x1, x2, x3], state, f) == f(x1, f(x2, f(x3, state)))</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan_right</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a4fdf082af400671e43a4035e14ae7f82">scan_right</a>([x1, x2, x3], state, f) == [</div>
<div class="line">    f(x1, f(x2, f(x3, state))),</div>
<div class="line">          f(x2, f(x3, state)),</div>
<div class="line">                f(x3, state),</div>
<div class="line">                      state</div>
<div class="line">]</div>
</div><!-- fragment --><p>Similarly, consider this right fold (without an initial state) on a short sequence: </p><div class="fragment"><div class="line">fold_right([x1, x2, x3, x4], f) == f(x1, f(x2, f(x3, x4)))</div>
</div><!-- fragment --><p>The analogous sequence generated with <code>scan_right</code> will be </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a4fdf082af400671e43a4035e14ae7f82">scan_right</a>([x1, x2, x3, x4], f) == [</div>
<div class="line">    f(x1, f(x2, f(x3, x4))),</div>
<div class="line">          f(x2, f(x3, x4)),</div>
<div class="line">                f(x3, x4),</div>
<div class="line">                      x4</div>
<div class="line">]</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to scan from the right.</td></tr>
    <tr><td class="paramname">state</td><td>The (optional) initial reduction state.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the sequence. When no initial state is provided, <code>f</code> is called as <code>f(x1, x2)</code>, where<code>x1</code> and <code>x2</code> are elements of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scan__right_8hpp.html">boost/hana/scan_right.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> element, <span class="keyword">auto</span> state) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(element) + <span class="stringliteral">&quot;, &quot;</span> + to_string(state) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// with initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::scan_right(hana::make_tuple(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), 4, f) == hana::make_tuple(</div>
<div class="line">        <span class="stringliteral">&quot;f(1, f(2, f(3, 4)))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;f(2, f(3, 4))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;f(3, 4)&quot;</span>,</div>
<div class="line">        4</div>
<div class="line">    ));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// without initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::scan_right(hana::make_tuple(1, <span class="stringliteral">&quot;2&quot;</span>, <span class="charliteral">&#39;3&#39;</span>), f) == hana::make_tuple(</div>
<div class="line">        <span class="stringliteral">&quot;f(1, f(2, 3))&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;f(2, 3)&quot;</span>,</div>
<div class="line">        <span class="charliteral">&#39;3&#39;</span></div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a18968c488a8b0cdc2697296024da9293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; from, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Extract a subsequence delimited by the given indices. </p>
<p>Specifically, <code>slice(xs, from, to)</code> is a sequence containing all the elements of <code>xs</code> at indices in the half-open interval delimited by [<code>from</code>, <code>to</code>). Note that the indices are 0-based. For this operation to be valid, <code>xs</code> must contain at least <code>to + 1</code> elements, and it must be true that <code>from &lt;= to</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to slice.</td></tr>
    <tr><td class="paramname">from</td><td>The index of the first element in the slice. <code>from</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type.</td></tr>
    <tr><td class="paramname">to</td><td>One-past the index of the last element in the slice. <code>to</code> must be a non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type such that <code>from &lt;= to</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slice_8hpp.html">boost/hana/slice.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::slice(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, hana::type_c&lt;float&gt;), hana::size_t&lt;1&gt;, hana::size_t&lt;3&gt;)</div>
<div class="line">    ==</div>
<div class="line">    hana::make_tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="afa204f71aac9f461d8574653295c67ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t from, std::size_t to&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto slice_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::slice(forwarded(xs), hana::size_t&lt;from&gt;, hana::size_t&lt;to&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>slice</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slice_8hpp.html">boost/hana/slice.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::slice_c&lt;1, 3&gt;(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, hana::type_c&lt;float&gt;))</div>
<div class="line">            ==</div>
<div class="line">    hana::make_tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a58c1454689bf6d2264bc428dc1d039db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto sort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sort a sequence, optionally based on a custom <code>predicate</code>. </p>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> and an optional predicate (by default <code>less</code>), <code>sort</code> returns a new sequence containing the same elements as the original, except they are ordered in such a way that if <code>x</code> comes before <code>y</code> in the sequence, then either <code>predicate(x, y)</code> is true, or both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false.</p>
<p>Also note that the sort is guaranteed to be stable. Hence, if <code>x</code> comes before <code>y</code> in the original sequence and both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false, then <code>x</code> will come before <code>y</code> in the resulting sequence.</p>
<p>If no predicate is provided, the elements in the sequence must all be compile-time <code><a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code>.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S(T)</code>, a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code> and a binary predicate \( T \times T \to Bool \), <code>sort</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathtt{sort} : S(T) \times (T \times T \to Bool) \to S(T) \]
</p>
<p>for the variant without a custom predicate, the <code>T</code> data type is required to be <code><a class="el" href="structboost_1_1hana_1_1Orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a></code>. The signature is then </p><p class="formulaDsp">
\[ \mathtt{sort} : S(T) \to S(T) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to sort.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code> for two elements <code>x</code> and <code>y</code> of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> is to be considered <em>less</em> than <code>y</code>, i.e. whether <code>x</code> should appear <em>before</em> <code>y</code> in the resulting sequence. More specifically, <code>predicate</code> must define a <a href="http://en.wikipedia.org/wiki/Strict_weak_ordering">strict weak ordering</a> on the elements of the sequence. In the current version of the library, also note that <code>predicate</code> must return a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> when called with any two elements of the sequence. When the predicate is not specified, this defaults to <code>less</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>sort.by</code>) </h2>
<p><code>sort</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a58c1454689bf6d2264bc428dc1d039db">sort</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>sort(-, predicate)</code> denotes the partial application of <code>sort</code> to <code>predicate</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="front_8hpp.html">boost/hana/front.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="greater_8hpp.html">boost/hana/greater.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="negate_8hpp.html">boost/hana/negate.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ordering_8hpp.html">boost/hana/ordering.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sort_8hpp.html">boost/hana/sort.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// sort without a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::sort(hana::make_tuple(1_c, -2_c, 3_c, 0_c)) ==</div>
<div class="line">               hana::make_tuple(-2_c, 0_c, 1_c, 3_c)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// sort with a predicate</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::sort(hana::make_tuple(1_c, -2_c, 3_c, 0_c), hana::greater) ==</div>
<div class="line">               hana::make_tuple(3_c, 1_c, 0_c, -2_c)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// sort.by is syntactic sugar</span></div>
<div class="line">    <span class="keyword">auto</span> tuples = hana::make_tuple(</div>
<div class="line">        hana::make_tuple(2_c, <span class="charliteral">&#39;x&#39;</span>, <span class="keyword">nullptr</span>),</div>
<div class="line">        hana::make_tuple(1_c, <span class="stringliteral">&quot;foobar&quot;</span>s, hana::int_&lt;4&gt;)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::sort.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::ordering(hana::front), tuples)</div>
<div class="line">            == hana::make_tuple(</div>
<div class="line">                hana::make_tuple(1_c, <span class="stringliteral">&quot;foobar&quot;</span>s, hana::int_&lt;4&gt;),</div>
<div class="line">                hana::make_tuple(2_c, <span class="charliteral">&#39;x&#39;</span>, <span class="keyword">nullptr</span>)</div>
<div class="line">            )</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab663fc84c23656a41d4dfcb586f0085c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto span</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence. </p>
<p>The first component of the returned <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a sequence for which all elements satisfy the given predicate. The second component of the returned <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code> is a sequence containing the remainder of the argument. Both or either sequences may be empty, depending on the input argument. More specifically, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, predicate) == make_pair(<a class="code" href="structboost_1_1hana_1_1Sequence.html#a86916c5c62a42f01f85450b366ef6eff">take_while</a>(xs, predicate),</div>
<div class="line">                                 drop_while(xs, predicate))</div>
</div><!-- fragment --><p> except that <code>make_pair</code> may be an arbitrary <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S(T)</code>, a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code> and a predicate \( T \to Bool \), <code>span</code> has the following signature: </p><p class="formulaDsp">
\[ \mathtt{span} : S(T) \times (T \to Bool) \to S(T) \times S(T) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to break into two parts.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>. In the current implementation of the library,</code>predicate<code>has to return a compile-time</code>Logical`.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>span.by</code>) </h2>
<p><code>span</code> can be called in an alternate way, which provides a nice syntax in some cases where the predicate is short: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#ab663fc84c23656a41d4dfcb586f0085c">span</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>span(-, predicate)</code> denotes the partial application of <code>span</code> to <code>predicate</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="less_8hpp.html">boost/hana/less.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="span_8hpp.html">boost/hana/span.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(hana::int_&lt;1&gt;, hana::int_&lt;2&gt;, hana::int_&lt;3&gt;, hana::int_&lt;4&gt;);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::span(xs, hana::less.than(hana::int_&lt;3&gt;))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(hana::make_tuple(hana::int_&lt;1&gt;, hana::int_&lt;2&gt;),</div>
<div class="line">                    hana::make_tuple(hana::int_&lt;3&gt;, hana::int_&lt;4&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::span(xs, hana::less.than(hana::int_&lt;0&gt;))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(hana::make_tuple(), xs)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::span(xs, hana::less.than(hana::int_&lt;5&gt;))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(xs, hana::make_tuple())</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="comment">// span.by is syntactic sugar</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::span.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::less.than(hana::int_&lt;3&gt;), xs)</div>
<div class="line">    ==</div>
<div class="line">    hana::make_pair(hana::make_tuple(hana::int_&lt;1&gt;, hana::int_&lt;2&gt;),</div>
<div class="line">                    hana::make_tuple(hana::int_&lt;3&gt;, hana::int_&lt;4&gt;))</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a65b5d2d363fb5e2d444e8bfe6bc712c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto subsequence</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; indices) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the elements at the given indices of a sequence. </p>
<p>Given a (finite) and compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> containing indices, <code>subsequence</code> returns a new <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> of the elements of the original sequence that appear at those indices. The indices must be <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s of an unsigned integral type. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a65b5d2d363fb5e2d444e8bfe6bc712c7">subsequence</a>([x1, ..., xn], [i1, ..., ik]) == [xi1, ..., xik]</div>
</div><!-- fragment --><p>In particular, note that indices do not have to be ordered or sequential in any particular way, and they may contain duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence from which a subsequence is extracted.</td></tr>
    <tr><td class="paramname">indices</td><td>A compile-time <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> holding <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s of an unsigned integral type, and whose linearization represents the indices of the elements in the returned sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2convert_8hpp.html">boost/hana/core/convert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filter_8hpp.html">boost/hana/filter.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rem_8hpp.html">boost/hana/rem.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="subsequence_8hpp.html">boost/hana/subsequence.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> letters = hana::to&lt;hana::Tuple&gt;(hana::range_c&lt;char, &#39;a&#39;, &#39;z&#39;&gt;);</div>
<div class="line">constexpr <span class="keyword">auto</span> indices = hana::to&lt;hana::Tuple&gt;(hana::make_range(hana::int_&lt;0&gt;, hana::length(letters)));</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> even_indices = hana::filter(indices, [](<span class="keyword">auto</span> n) {</div>
<div class="line">    <span class="keywordflow">return</span> n % hana::uint&lt;2&gt; == hana::uint&lt;0&gt;;</div>
<div class="line">});</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::subsequence(letters, even_indices) == hana::tuple_c&lt;<span class="keywordtype">char</span>,</div>
<div class="line">        <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="charliteral">&#39;y&#39;</span></div>
<div class="line">    &gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2c20028c5115dcf38063d322f27b4ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; n) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the first <code>n</code> elements of a sequence, or the whole sequence if the sequence has less than <code>n</code> elements. </p>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>xs</code> and a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>n</code> holding an unsigned integral value, <code>take(xs, n)</code> is a new sequence containing the first <code>n</code> elements of <code>xs</code>, in the same order. If <code>length(xs) &lt;= n</code>, the whole sequence is returned and no error is triggered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to take the elements from.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> holding an unsigned integral value representing the number of elements to keep in the resulting sequence.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="take_8hpp.html">boost/hana/take.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::take(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::size_t&lt;0&gt;) == hana::make_tuple());</div>
<div class="line">static_assert(hana::take(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::size_t&lt;1&gt;) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::take(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::size_t&lt;2&gt;) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::take(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::size_t&lt;3&gt;) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::take(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::size_t&lt;4&gt;) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a63f9ab281c8e979adfd7f6678383c46b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::take(forwarded(xs), hana::size_t&lt;n&gt;);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Equivalent to <code>take</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="take_8hpp.html">boost/hana/take.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::take_c&lt;2&gt;(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a86916c5c62a42f01f85450b366ef6eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto take_while</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Take elements from a sequence while the <code>predicate</code> is satisfied. </p>
<p>Specifically, <code>take_while</code> returns a new sequence containing the longest prefix of <code>xs</code> in which all the elements satisfy the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence to take elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> should be included in the resulting sequence. In the current version of the library, <code>predicate</code> has to return a <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="less_8hpp.html">boost/hana/less.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="take__while_8hpp.html">boost/hana/take_while.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::take_while(hana::tuple_c&lt;int, 0, 1, 2, 3&gt;, hana::less.than(2_c))</div>
<div class="line">    ==</div>
<div class="line">    hana::tuple_c&lt;int, 0, 1&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a435bb610ac90db4df48bd3fce876b8a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfold_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Dual operation to <code>fold_left</code> for sequences. </p>
<p>While <code>fold_left</code> reduces a structure to a summary value from the left, <code>unfold_left</code> builds a sequence from a seed value and a function, starting from the left.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S</code>, an initial value <code>state</code> of tag <code>I</code>, an arbitrary <a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a> <code>P</code> and a function \( f : I \to P(I, T) \), <code>unfold_left&lt;S&gt;</code> has the following signature: </p><p class="formulaDsp">
\[ \mathtt{unfold\_left}_S : I \times (I \to P(I, T)) \to S(T) \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The tag of the sequence to build up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>An initial value to build the sequence from.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(state)</code>, where <code>state</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the sequence.</li>
<li>otherwise, <code>just(make&lt;P&gt;(state, x))</code>, where <code>state</code> is the new initial value used in the next call to <code>f</code>, <code>x</code> is an element to be appended to the resulting sequence, and <code>P</code> is an arbitrary <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Fun fact </h2>
<p>In some cases, <code>unfold_left</code> can undo a <code>fold_left</code> operation: </p><div class="fragment"><div class="line">unfold_left&lt;S&gt;(fold_left(xs, state, f), g) == xs</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(make_pair(x, y))</div>
<div class="line">g(state) == nothing</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="if_8hpp.html">boost/hana/if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minus_8hpp.html">boost/hana/minus.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unfold__left_8hpp.html">boost/hana/unfold_left.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::unfold_left&lt;hana::Tuple&gt;(hana::int_&lt;10&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::if_(x == hana::int_&lt;0&gt;,</div>
<div class="line">            hana::nothing,</div>
<div class="line">            hana::just(hana::make_pair(x - hana::int_&lt;1&gt;, x))</div>
<div class="line">        );</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    hana::tuple_c&lt;int, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acd815736023ac04d4cb8f99c4c490442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unfold_right</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; state, <span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Dual operation to <code>fold_right</code> for sequences. </p>
<p>While <code>fold_right</code> reduces a structure to a summary value from the right, <code>unfold_right</code> builds a sequence from a seed value and a function, starting from the right.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S</code>, an initial value <code>state</code> of tag <code>I</code>, an arbitrary <a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a> <code>P</code> and a function \( f : I \to P(T, I) \), <code>unfold_right&lt;S&gt;</code> has the following signature: </p><p class="formulaDsp">
\[ \mathtt{unfold\_right}_S : I \times (I \to P(T, I)) \to S(T) \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The tag of the sequence to build up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>An initial value to build the sequence from.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(state)</code>, where <code>state</code> is an initial value, and returning<ol type="1">
<li><code>nothing</code> if it is done producing the sequence.</li>
<li>otherwise, <code>just(make&lt;P&gt;(x, state))</code>, where <code>state</code> is the new initial value used in the next call to <code>f</code>, <code>x</code> is an element to be prepended to the resulting sequence, and <code>P</code> is an arbitrary <code><a class="el" href="structboost_1_1hana_1_1Product.html" title="Represents types that are generic containers of two elements. ">Product</a></code>.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<h2>Fun fact </h2>
<p>In some cases, <code>unfold_right</code> can undo a <code>fold_right</code> operation: </p><div class="fragment"><div class="line">unfold_right&lt;S&gt;(fold_right(xs, state, f), g) == xs</div>
</div><!-- fragment --><p>if the following holds </p><div class="fragment"><div class="line">g(f(x, y)) == just(make_pair(x, y))</div>
<div class="line">g(state) == nothing</div>
</div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="if_8hpp.html">boost/hana/if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minus_8hpp.html">boost/hana/minus.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unfold__right_8hpp.html">boost/hana/unfold_right.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::unfold_right&lt;hana::Tuple&gt;(hana::int_&lt;10&gt;, [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> hana::if_(x == hana::int_&lt;0&gt;,</div>
<div class="line">            hana::nothing,</div>
<div class="line">            hana::just(hana::make_pair(x, x - hana::int_&lt;1&gt;))</div>
<div class="line">        );</div>
<div class="line">    })</div>
<div class="line">    ==</div>
<div class="line">    hana::tuple_c&lt;int, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a00c9ad102df93f8e88c37afd92f34590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto unique</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Removes all consecutive duplicate elements from a <a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>. </p>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> and an optional binary predicate, <code>unique</code> returns a new sequence containing only the first element of every subrange of the original sequence whose elements are all equal. In other words, it turns a sequence of the form <code>[a, a, b, c, c, c, d, d, d, a]</code> into a sequence <code>[a, b, c, d, a]</code>. The equality of two elements is determined by the provided <code>predicate</code>, or by <code>equal</code> if no <code>predicate</code> is provided.</p>
<h2>Signature </h2>
<p>Given a <code><a class="el" href="structboost_1_1hana_1_1Sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a></code> <code>S(T)</code>, a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code> and a binary predicate \( T \times T \to Bool \), <code>unique</code> has the following signature: </p><p class="formulaDsp">
\[ \mathtt{unique} : S(T) \times (T \times T \to Bool) \to S(T) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The sequence from which to remove consecutive duplicates.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are adjacent elements of the sequence, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>x</code> and <code>y</code> should be considered equal. <code>predicate</code> should define an <a href="http://en.wikipedia.org/wiki/Equivalence_relation#Definition">equivalence relation</a> over the elements of the sequence. In the current implementation of the library, <code>predicate</code> has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. This parameter is optional; it defaults to <code>equal</code> if it is not provided, which then requires the elements of the sequence to be compile-time <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Syntactic sugar (<code>unique.by</code>) </h2>
<p><code>unique</code> can be called in an alternate way, which provides a nice syntax, especially in conjunction with the <code>comparing</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a00c9ad102df93f8e88c37afd92f34590">unique</a>.by(predicate, xs) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a00c9ad102df93f8e88c37afd92f34590">unique</a>(xs, predicate)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Sequence.html#a00c9ad102df93f8e88c37afd92f34590">unique</a>.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(predicate) == <a class="code" href="structboost_1_1hana_1_1Sequence.html#a00c9ad102df93f8e88c37afd92f34590">unique</a>(-, predicate)</div>
</div><!-- fragment --><p>where <code>unique(-, predicate)</code> denotes the partial application of <code>unique</code> to <code>predicate</code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="comparing_8hpp.html">boost/hana/comparing.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unique_8hpp.html">boost/hana/unique.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// unique without a predicate</span></div>
<div class="line">constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, float, float, char, int, int, int, double&gt;;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::unique(types) == hana::tuple_t&lt;int, float, char, int, double&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// unique with a predicate</span></div>
<div class="line">    <span class="keyword">auto</span> objects = hana::make_tuple(1, 2, <span class="stringliteral">&quot;abc&quot;</span>s, <span class="charliteral">&#39;d&#39;</span>, <span class="stringliteral">&quot;efg&quot;</span>s, <span class="stringliteral">&quot;hij&quot;</span>s, 3.4f);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::unique(objects, [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; t, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; u) {</div>
<div class="line">            <span class="keywordflow">return</span> hana::decltype_(t) == hana::decltype_(u);</div>
<div class="line">        })</div>
<div class="line">        == hana::make_tuple(1, <span class="stringliteral">&quot;abc&quot;</span>s, <span class="charliteral">&#39;d&#39;</span>, <span class="stringliteral">&quot;efg&quot;</span>s, 3.4f)</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// unique.by is syntactic sugar</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        hana::unique.<a class="code" href="group__group-details.html#ga1f92c27de855a682eebde5f7d0138d18">by</a>(hana::comparing(hana::decltype_), objects) ==</div>
<div class="line">            hana::make_tuple(1, <span class="stringliteral">&quot;abc&quot;</span>s, <span class="charliteral">&#39;d&#39;</span>, <span class="stringliteral">&quot;efg&quot;</span>s, 3.4f)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a23b6ac9e78577d70b9108a80e6b1534c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x1, ..., <span class="keyword">auto</span>&amp;&amp; xn) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Zip one sequence or more. </p>
<p>Given <code>n</code> sequences <code>s1, ..., sn</code>, <code>zip</code> produces a sequence whose <code>i</code>-th element is a tuple of <code>(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the <code>i</code>-th element of the <code>k</code>-th sequence. In other words, <code>zip</code> produces a sequence of the form </p><div class="fragment"><div class="line">[</div>
<div class="line">    make_tuple(s1[0], ..., sn[0]),</div>
<div class="line">    make_tuple(s1[1], ..., sn[1]),</div>
<div class="line">    ...</div>
<div class="line">    make_tuple(s1[M], ..., sn[M])</div>
<div class="line">]</div>
</div><!-- fragment --><p> where <code>M</code> is the length of the sequences, which are all assumed to have the same length. Assuming the sequences to all have the same size allows the library to perform some optimizations. To zip sequences that may have different lengths, <code>zip_shortest</code> should be used instead. Also note that it is an error to provide no sequence at all, i.e. <code>zip</code> expects at least one sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="zip_8hpp.html">boost/hana/zip.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::zip(hana::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>), hana::make_tuple(2, 3.3))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_tuple(hana::make_tuple(1, 2), hana::make_tuple(<span class="charliteral">&#39;a&#39;</span>, 3.3))</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a10f6d2040b9c9f2aea6a334e41c89ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip_shortest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x1, ..., <span class="keyword">auto</span>&amp;&amp; xn) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Zip one sequence or more. </p>
<p>Given <code>n</code> sequences <code>s1, ..., sn</code>, <code>zip_shortest</code> produces a sequence whose <code>i</code>-th element is a tuple of <code>(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the <code>i</code>-th element of the <code>k</code>-th sequence. In other words, <code>zip_shortest</code> produces a sequence of the form </p><div class="fragment"><div class="line">[</div>
<div class="line">    make_tuple(s1[0], ..., sn[0]),</div>
<div class="line">    make_tuple(s1[1], ..., sn[1]),</div>
<div class="line">    ...</div>
<div class="line">    make_tuple(s1[M], ..., sn[M])</div>
<div class="line">]</div>
</div><!-- fragment --><p> where <code>M</code> is the length of the shortest sequence. Hence, the returned sequence stops when the shortest input sequence is exhausted. If you know that all the sequences you are about to zip have the same length, you should use <code>zip</code> instead, since it can be more optimized. Also note that it is an error to provide no sequence at all, i.e. <code>zip_shortest</code> expects at least one sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="zip__shortest_8hpp.html">boost/hana/zip_shortest.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::zip_shortest(hana::make_tuple(1, <span class="charliteral">&#39;a&#39;</span>), hana::make_tuple(2, 3.3), hana::make_tuple(3, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_tuple(hana::make_tuple(1, 2, 3), hana::make_tuple(<span class="charliteral">&#39;a&#39;</span>, 3.3, <span class="charliteral">&#39;c&#39;</span>))</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aef70e8791ace2fafabf0ff3adaa8630c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip_shortest_with</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; x1, ..., <span class="keyword">auto</span>&amp;&amp; xn) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Zip one sequence or more with a given function. </p>
<p>Given a <code>n</code>-ary function <code>f</code> and <code>n</code> sequences <code>s1, ..., sn</code>, <code>zip_shortest_with</code> produces a sequence whose <code>i</code>-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the <code>i</code>-th element of the <code>k</code>-th sequence. In other words, <code>zip_shortest_with</code> produces a sequence of the form </p><div class="fragment"><div class="line">[</div>
<div class="line">    f(s1[0], ..., sn[0]),</div>
<div class="line">    f(s1[1], ..., sn[1]),</div>
<div class="line">    ...</div>
<div class="line">    f(s1[M], ..., sn[M])</div>
<div class="line">]</div>
</div><!-- fragment --><p> where <code>M</code> is the length of the shortest sequence. Hence, the returned sequence stops when the shortest input sequence is exhausted. If you know that all the sequences you are about to zip have the same length, you should use <code>zip_with</code> instead, since it can be more optimized. Also note that it is an error to provide no sequence at all, i.e. <code>zip_shortest_with</code> expects at least one sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mult_8hpp.html">boost/hana/mult.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="zip__shortest__with_8hpp.html">boost/hana/zip_shortest_with.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::zip_shortest_with(hana::mult, hana::make_tuple(1, 2, 3, 4), hana::make_tuple(5, 6, 7, 8, <span class="stringliteral">&quot;ignored&quot;</span>))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_tuple(5, 12, 21, 32)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5eadaf63535ebb8cdd8d9e4c16b9bacd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto zip_with</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; x1, ..., <span class="keyword">auto</span>&amp;&amp; xn) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Zip one sequence or more with a given function. </p>
<p>Given a <code>n</code>-ary function <code>f</code> and <code>n</code> sequences <code>s1, ..., sn</code>, <code>zip_with</code> produces a sequence whose <code>i</code>-th element is <code>f(s1[i], ..., sn[i])</code>, where <code>sk[i]</code> denotes the <code>i</code>-th element of the <code>k</code>-th sequence. In other words, <code>zip_with</code> produces a sequence of the form </p><div class="fragment"><div class="line">[</div>
<div class="line">    f(s1[0], ..., sn[0]),</div>
<div class="line">    f(s1[1], ..., sn[1]),</div>
<div class="line">    ...</div>
<div class="line">    f(s1[M], ..., sn[M])</div>
<div class="line">]</div>
</div><!-- fragment --><p> where <code>M</code> is the length of the sequences, which are all assumed to have the same length. Assuming the sequences to all have the same size allows the library to perform some optimizations. To zip sequences that may have different lengths, <code>zip_shortest_with</code> should be used instead. Also note that it is an error to provide no sequence at all, i.e. <code>zip_with</code> expects at least one sequence.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mult_8hpp.html">boost/hana/mult.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="zip__with_8hpp.html">boost/hana/zip_with.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::zip_with(hana::mult, hana::make_tuple(1, 2, 3, 4), hana::make_tuple(5, 6, 7, 8))</div>
<div class="line">    ==</div>
<div class="line">    hana::make_tuple(5, 12, 21, 32)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Sequence.html">Sequence</a></li>
  </ul>
</div>
</body>
</html>
