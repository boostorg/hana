<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Boost.Hana: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="structboost_1_1hana_1_1_applicative.html#a0d7511a7a164af8cc6040052b3fbee51">ap</a>  </dt>
<dd>Consider giving access to all the arguments to the type class implementation. This is for performance purposes.  </dd>
<dt><a class="anchor" id="_todo000009"></a>Class <a class="el" href="structboost_1_1hana_1_1_applicative_1_1instance_3_01_std_tuple_01_4.html">boost::hana::Applicative::instance&lt; StdTuple &gt;</a>  </dt>
<dd>Get rid of this redundant instance once <a href="http://llvm.org/bugs/show_bug.cgi?id=19616">http://llvm.org/bugs/show_bug.cgi?id=19616</a> is fixed.  </dd>
<dt><a class="anchor" id="_todo000002"></a>Class <a class="el" href="structboost_1_1hana_1_1_applicative_1_1laws.html">boost::hana::Applicative::laws</a>  </dt>
<dd>Actually implement and check the laws.  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="group___functional.html#ga6acc765a35c4dc85f0deab4785831a3d">boost::hana::arg</a>  </dt>
<dd>Maybe this should be <code>arg(n)</code> instead of <code>arg&lt;n&gt;</code>? It's more consistent but harder to use since we have to write <code>arg(int_&lt;n&gt;)(...)</code> instead of <code>arg&lt;n&gt;(...)</code>.  </dd>
<dt><a class="anchor" id="_todo000003"></a>Class <a class="el" href="structboost_1_1hana_1_1_constant.html">boost::hana::Constant</a>  </dt>
<dd>Integrate this with <code>Integral</code> and the rest of the library.  </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="group___functional.html#ga49ea872ade5ac8f6c10052c495302e89">boost::hana::curry</a>  </dt>
<dd>Consider making <code>curry&lt;0&gt;(f)</code> equivalent to <code>f</code>. It might be more general or less useful if it creates subtle pitfalls. </dd>
<dt><a class="anchor" id="_todo000006"></a>Class <a class="el" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt; T, Enable &gt;</a>  </dt>
<dd><ul>
<li>Could this be related to <code>decltype_</code>? If so, how? It is a valid question whether <code>decltype_(list(...))</code> should be <code>List</code> or <code>&lt;garbage&gt;</code>.</li>
<li>Consider using two layers of specializations to improve performance if this is an issue. I suspect that using the enabler will hurt performance a lot because it requires the compiler to look at all the enablers each time <code>datatype</code> is instantiated.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="group___functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">boost::hana::demux</a>  </dt>
<dd><ul>
<li>I think this is equivalent to <code>fmap . fmap</code>. See <a href="http://stackoverflow.com/q/5821089/627587">http://stackoverflow.com/q/5821089/627587</a> </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Class <a class="el" href="structboost_1_1hana_1_1_integral.html">boost::hana::Integral</a>  </dt>
<dd>Implicit conversions to the underlying integral type can be problematic: <div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % int_&lt;2&gt;;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_logical.html#a06927a2badb729e1522b9030d18234df">if_</a>(odd(int_&lt;1&gt;), something_of_type_A, something_of_type_B)</div>
</div><!-- fragment --> This will fail because <code>odd(int_&lt;1&gt;)</code> has type <code>Int&lt;1 % 2&gt;</code>, which is convertible to <code>bool</code> but not to <code>Bool&lt;...&gt;</code>. Because of this, the runtime <code>if_</code> is used and compilation fails.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Class <a class="el" href="structboost_1_1hana_1_1_iterable.html">boost::hana::Iterable</a>  </dt>
<dd><ul>
<li>What about infinite <code>Iterable</code>s?</li>
<li>There are probably tons of laws that must be respected?  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000018"></a>Class <a class="el" href="structboost_1_1hana_1_1_lazy.html">boost::hana::Lazy</a>  </dt>
<dd>Right now, we can't do <code>lazy(f)()</code> because <code>ap(f)</code> is invalid. How should we fix this?  </dd>
<dt><a class="anchor" id="_todo000021"></a>Class <a class="el" href="structboost_1_1hana_1_1_list.html">boost::hana::List</a>  </dt>
<dd><ul>
<li>It might be possible to optimize the implementation of homogeneous lists using an array.</li>
<li>How to implement iterate and repeat?</li>
<li>Check laws for <code>Applicative</code>.</li>
<li>Get rid of the <code>&lt;type_traits&gt;</code> include.</li>
<li>We could provide automatic unit testing for any instance because we have the isomorphisms.</li>
<li>There is a strong relationship between this and <code>MonadPlus</code>. Actually, they might be just the same. Check this out.</li>
<li>Implement the following methods:<ul>
<li><code>unfoldr</code>, <code>unfoldl</code>, <code>unzip</code></li>
<li><code>intersperse</code>, <code>intercalate</code>, <code>transpose</code>, <code>subsequences</code></li>
<li><code>split_at</code>, <code>span</code>, <code>break</code>, <code>group_by</code>, <code>group</code>, <code>inits</code>, <code>tails</code></li>
</ul>
</li>
<li>Consider implementing the following methods:<ul>
<li><code>nub_by</code>, <code>nub</code>, <code>delete_by</code>, <code>insert</code></li>
<li><code>set_difference_by</code>, <code>set_union_by</code>, <code>set_intersection_by</code>  </li>
</ul>
</li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="group___functional.html#gafca60c09e1f7a32a2b52baaf6515c279">boost::hana::lockstep</a>  </dt>
<dd>I think this is equivalent to <code>&lt;*&gt;</code> for <code>((-&gt;) r)</code>. </dd>
<dt><a class="anchor" id="_todo000025"></a>Class <a class="el" href="structboost_1_1hana_1_1_logical.html">boost::hana::Logical</a>  </dt>
<dd><ul>
<li>Use a non-naive implementation for variadic <code>and_</code> and <code>or_</code>.</li>
<li>Consider making this a real boolean algebra. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000026"></a>Class <a class="el" href="structboost_1_1hana_1_1_monad.html">boost::hana::Monad</a>  </dt>
<dd><ul>
<li>Consider adding a function to tap inside a monadic chain. This is probably the same as Haskell's <code>&gt;&gt;</code>.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000007"></a>Class <a class="el" href="structboost_1_1hana_1_1operators_1_1enable.html">boost::hana::operators::enable</a>  </dt>
<dd>Is ADL really the best way of providing custom operators? This has (at least) the problem that templated types which have nothing to do with Boost.Hana could have their set of associated namespaces augmented with <code>boost::hana::operators</code> in an undesirable way: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>nothing_to_do_with_hana { };</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = operators::enable&gt;</div>
<div class="line"><span class="keyword">struct </span>something_to_do_with_hana { };</div>
<div class="line"></div>
<div class="line">nothing_to_do_with_hana&lt;something_to_do_with_hana&lt;int&gt;&gt; x{};</div>
<div class="line">x == x; <span class="comment">// tries to use Comparable::equal_impl</span></div>
</div><!-- fragment -->  </dd>
<dt><a class="anchor" id="_todo000027"></a>Class <a class="el" href="structboost_1_1hana_1_1_pair.html">boost::hana::Pair</a>  </dt>
<dd>Provide and document instances for <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> and <code>Foldable</code>.  </dd>
<dt><a class="anchor" id="_todo000028"></a>Class <a class="el" href="structboost_1_1hana_1_1_searchable.html">boost::hana::Searchable</a>  </dt>
<dd>Explain how key/value works for searchables.  </dd>
<dt><a class="anchor" id="_todo000023"></a>Class <a class="el" href="structboost_1_1hana_1_1_searchable_1_1instance_3_01_t_00_01when_3_01instantiates_3_01_list_00_01_t_01_4_07_08_4_01_4.html">boost::hana::Searchable::instance&lt; T, when&lt; instantiates&lt; List, T &gt;()&gt; &gt;</a>  </dt>
<dd>Technically, this can be implemented in <code>Iterable</code>. Should it? </dd>
<dt><a class="anchor" id="_todo000029"></a>Class <a class="el" href="structboost_1_1hana_1_1_type.html">boost::hana::Type</a>  </dt>
<dd><ul>
<li>Completely figure out and document the category theoretical foundation of this data type.</li>
<li>Consider instantiating <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> if that's possible.</li>
<li>Consider having a <code>.name()</code> method that would return the (demangled?) <code>typeid(T).name()</code>.</li>
<li>Use more lambdas once <a href="http://llvm.org/bugs/show_bug.cgi?id=20046">http://llvm.org/bugs/show_bug.cgi?id=20046</a> is fixed.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000032"></a>Class <a class="el" href="structboost_1_1hana_1_1_type_list.html">boost::hana::TypeList</a>  </dt>
<dd><ul>
<li>Efficient membership testing is possible.</li>
<li><code>TypeList</code> is not really a <code>Functor</code> because the function must map from <code>Type</code>s to <code>Type</code>s. Should it be modified so that <code>TypeList</code> becomesÂ <code>List</code> if we try to store something else than <code>Type</code>s? The same issue goes for <code>IntegerList</code>.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000015"></a>File <a class="el" href="foldable__instance_8hpp.html">foldable_instance.hpp</a>  </dt>
<dd>Fix headers including this. One possibility would be to provide the instance for Foldable when both foldable.hpp and iterable.hpp are included. </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="structboost_1_1hana_1_1_iterable.html#a80176fbdfbccc09e902263557eb0984d">for_each</a>  </dt>
<dd>This should probably be in a future <code>Traversable</code> type class.  </dd>
<dt><a class="anchor" id="_todo000033"></a>File <a class="el" href="hana_8hpp.html">hana.hpp</a>  </dt>
<dd><ul>
<li>When we have functions with several variants, consider naming versions with the following scheme: <div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a>.lazy</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a>.strict</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_foldable.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a> == <a class="code" href="structboost_1_1hana_1_1_foldable.html#ab1dcc2a64352a571154c2ebd8fd1b37d">foldr</a>.strict</div>
</div><!-- fragment --> That would be prettier and not much more complicated. However, we would need a naming convention for the <code>_impl</code> versions of those.</li>
<li>To consider: is it possible/desirable to eliminate partial functions? For example, removing <code>head</code> and <code>tail</code>, which can fail, and replace them by a function which returns a <code>Maybe</code>.</li>
<li>Document the library's stance on perfect forwarding and move semantics. Make compile-time tests with non-copyable types and runtime tests with expensive-to-copy types.</li>
<li>In the unit tests, we might want to use an injective function on <code>Comparable</code>s instead of <code>std::make_tuple</code>.</li>
<li>Write a tutorial. In particular:<ul>
<li>Document how to emulate <code>make_fused</code> and friends from Boost.Fusion.</li>
<li>Document how to write common Boost.Fusion and Boost.MPL idioms with Boost.Hana.</li>
</ul>
</li>
<li>Write runtime benchmarks.</li>
<li>Setup a BJam build system.</li>
<li>Provide a Main page for the Doxygen documentation.</li>
<li>Consider making function objects automatically curriable. This could allow <em>super sexy</em> stuff like: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Iterable&lt;List&gt; {</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">auto</span> length_impl = foldl(some_lambda, size_t&lt;0&gt;);</div>
<div class="line">};</div>
</div><!-- fragment --> </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000019"></a>File <a class="el" href="list_2instance_8hpp.html">instance.hpp</a>  </dt>
<dd>Find a way to get rid of this header. Same goes for <a class="el" href="pair_2instance_8hpp.html" title="Defines the boost::hana::Pair instance. ">pair/instance.hpp</a>. </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="structboost_1_1hana_1_1_list.html#a7d7c9b8e94dfcac46c7427a9b82e3225">list</a>  </dt>
<dd>Consider having <code>list_of&lt;Type&gt;</code>, <code>list_of&lt;Integral&gt;</code>, ..., <code>list_of&lt;Anything&gt;</code>, with <code>list == list_of&lt;Anything&gt;</code>. It does not fix the problem of partial type classes (e.g. <code>MplVector</code> is not <em>actually</em> a <code>List</code>), but at least we remove <code>TypeList</code> and <code>IntegerList</code>, which are arguably ugly.  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="structboost_1_1hana_1_1_integral.html#a1c078fd00db48686ca9e0aa17f47344e">operator</a> "_c" </dt>
<dd>Add support for stuff like <code>0x1234_c</code>.  </dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="structboost_1_1hana_1_1_type.html#a5286be1cfdaca72680089a7d15a5c14c">sizeof_</a>  </dt>
<dd>Should we also support non-<code>Type</code>s? That could definitely be useful.  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="structboost_1_1hana_1_1_type.html#ab66de88586706cb474453dd937d13f8c">type</a>  </dt>
<dd>Should this fail or not? Currently it fails because "non-constant-expression cannot be narrowed from type 'double' to
'float' in initializer list" <div class="fragment"><div class="line">type&lt;float&gt;(<span class="keywordtype">double</span>{1.2})</div>
</div><!-- fragment -->  </dd>
<dt><a class="anchor" id="_todo000034"></a>Group <a class="el" href="group__typeclasses.html">typeclasses</a>  </dt>
<dd><ul>
<li>Implement better law checking and check them for all instances in the unit tests. Since we're modularized, it's OK to resort to heavy stuff in the law-checking because it's presumably only done in unit testing contexts.</li>
<li>Provide an integrated way of checking laws for type classes.</li>
<li>Provide a way to check type class requirements like <code>Functor f =&gt; Applicative f</code>.</li>
<li>Document requirements for the existing type classes.</li>
<li>Find a better way to provide instances between type classes; consider something like <code>Foldable::instance&lt;Iterable&gt;</code>.</li>
<li>Consider inheriting from a base class even when no mcd is required. That would allow us to <em>not</em> include a useless mcd.</li>
<li>Document the include structure for type classes and the contracts between headers (what needs to be included and when). Could look like typeclass.hpp &ndash; everything typeclass/typeclass.hpp &ndash; forward declaration, operators, methods, &ndash; default-provided orphan instances (like &ndash; bool for Logical). This one is included by &ndash; everyone else in typeclass/, by contract typeclass/mcd.hpp &ndash; definition of a mcd typeclass/laws.hpp &ndash; laws of the type class</li>
<li>Consider including the default provided instances in the mcds instead of the forward declaration header of a type class. However, that won't work for instances provided implicitly (e.g. Logical &lt;- bool or Comparable &lt;- x == y), because there is no MCD to be included for those.</li>
<li>Document the purpose of minimal instances; they are meant to provide an easy to use archetype for testing and their tests are meant to exercice the basic dispatching code of type classes (hence it makes sense to test even the mcd of a minimal instance). In particular, they are not meant to be <em>the</em> minimal instance, which does not exist in general (what does it even mean to be a <em>minimal</em> instance?)  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="structboost_1_1hana_1_1_list.html#a5eadaf63535ebb8cdd8d9e4c16b9bacd">zip_with</a>  </dt>
<dd><ul>
<li>Consider allowing only two lists and achieving the variadic behavior in some other way. This would make it possible to automatically curry <code>zip_with</code>. It might be possible to achieve the variadic behavior with e.g. Applicative Functors? </li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 22 2014 13:51:05 for Boost.Hana by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
