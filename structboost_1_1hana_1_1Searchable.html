<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Boost.Hana: boost::hana::Searchable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/9029554299b379bd015d102ecdcc5ff455469b6b/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/implementation-defined/g, "implementation-defined".link("index.html#tutorial-glossary-implementation_defined").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.2/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1Searchable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1Searchable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::Searchable Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> concept represents structures that can be searched. </p>
<p>Intuitively, a <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> is any structure, finite or infinite, containing elements that can be searched using a predicate. Sometimes, <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s will associate keys to values; one can search for a key with a predicate, and the value associated to it is returned. This gives rise to map-like data structures. Other times, the elements of the structure that are searched (i.e. those to which the predicate is applied) are the same that are returned, which gives rise to set-like data structures. In general, we will refer to the <em>keys</em> of a <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> structure as those elements that are used for searching, and to the <em>values</em> of a <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> as those elements that are returned when a search is successful. As was explained, there is no requirement that both notions differ, and it is often useful to have keys and values coincide (think about <code>std::set</code>).</p>
<p>Some methods like <code>any_of</code>, <code>all_of</code> and <code>none_of</code> allow simple queries to be performed on the keys of the structure, while other methods like <code>find</code> and <code>find_if</code> make it possible to find the value associated to a key. The most specific method should always be used if one cares about performance, because it is usually the case that heavy optimizations can be performed in more specific methods. For example, an associative data structure implemented as a hash table will be much faster to access using <code>find</code> than <code>find_if</code>, because in the second case it will have to do a linear search through all the entries. Similarly, using <code>contains</code> will likely be much faster than <code>any_of</code> with an equivalent predicate.</p>
<blockquote class="doxtable">
<p><b>Insight</b><br />
In a lazy evaluation context, any <code><a class="el" href="structboost_1_1hana_1_1Foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a></code> can also become a model of <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> because we can search lazily through the structure with <code>fold_right</code>. However, in the context of C++, some <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s can not be folded; think for example of an infinite set. </p>
</blockquote>
<h2>Minimal complete definition </h2>
<p><code>find_if</code> and <code>any_of</code></p>
<p>When <code>find_if</code> and <code>any_of</code> are provided, the other functions are implemented according to the laws explained below.</p>
<dl class="section note"><dt>Note</dt><dd>We could implement <code>any_of(xs, pred)</code> as <code>is_just(find_if(xs, pred))</code>, and then reduce the minimal complete definition to <code>find_if</code>. However, this is not done because that implementation requires the predicate of <code>any_of</code> to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>, which is more restrictive than what we have right now.</dd></dl>
<h2>Laws </h2>
<p>In order for the semantics of the methods to be consistent, some properties must be satisfied by any model of the <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> concept. Rigorously, for any <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s <code>xs</code> and <code>ys</code> and any predicate <code>p</code>, the following laws should be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, p) &lt;=&gt; !<a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(xs, negated p)</div>
<div class="line">              &lt;=&gt; !<a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(xs, p)</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a1b4a67c4fd522de62b101ed99bb423e3">contains</a>(xs, x) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(x))</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(xs, x) == <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(xs, equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(x))</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(false_)) == nothing</div>
<div class="line"></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a386ac8af7123ea1e8ea1fa2bbd4cbf3d">is_subset</a>(xs, ys) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(xs, [](auto x) { <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Searchable.html#a1b4a67c4fd522de62b101ed99bb423e3">contains</a>(ys, x); })</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a8d02fba3a74d476e179b4d9d8be6b6bb">is_disjoint</a>(xs, ys) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(xs, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1Searchable.html#a1b4a67c4fd522de62b101ed99bb423e3">contains</a>(ys, x); })</div>
</div><!-- fragment --><p>Additionally, if all the keys of the <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> are <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s, the following laws should be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a>(xs)  &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, <span class="keywordtype">id</span>)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a>(xs)  &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a>(xs, <span class="keywordtype">id</span>)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a>(xs) &lt;=&gt; <a class="code" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a>(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --><h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique and Comparable keys. ">hana::map</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants. ">hana::range</a></code>, <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring compile-time Comparable elements. ">hana::set</a></code>, <code><a class="el" href="structboost_1_1hana_1_1string.html" title="Compile-time string. ">hana::string</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code></p>
<h2>Free model for builtin arrays </h2>
<p>Builtin arrays whose size is known can be searched as-if they were homogeneous tuples. However, since arrays can only hold objects of a single type and the predicate to <code>find_if</code> must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>, the <code>find_if</code> method is fairly useless. For similar reasons, the <code>find</code> method is also fairly useless. This model is provided mainly because of the <code>any_of</code> method &amp; friends, which are both useful and compile-time efficient.</p>
<h2>Structure preserving functions </h2>
<p>Given two <code>Searchables</code> <code>S1</code> and <code>S2</code>, a function \( f : S_1(X) \to S_2(X) \) is said to preserve the <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> structure if for all <code>xs</code> of data type <code>S1(X)</code> and predicates \( \mathtt{pred} : X \to Bool \) (for a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> <code>Bool</code>), </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(xs, pred)  if and only if  <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a>(f(xs), pred)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(xs, pred) == <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(f(xs), pred)</div>
</div><!-- fragment --><p>This is really just a generalization of the following, more intuitive requirements. For all <code>xs</code> of data type <code>S1(X)</code> and <code>x</code> of data type <code>X</code>, </p><div class="fragment"><div class="line">x ^<a class="code" href="structboost_1_1hana_1_1Searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a>^ xs  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>  x ^<a class="code" href="structboost_1_1hana_1_1Searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a>^ f(xs)</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(xs, x) == <a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(f(xs), x)</div>
</div><!-- fragment --><p>These requirements can be understood as saying that <code>f</code> does not change the content of <code>xs</code>, although it may reorder elements. As usual, such a structure-preserving transformation is said to be an embedding if it is also injective, i.e. if it is a lossless transformation. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a695907e4a3ef7d0e9ab34f5afff709b2">all</a></td></tr>
<tr class="memdesc:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all the keys of the structure are true-valued.  <a href="#a695907e4a3ef7d0e9ab34f5afff709b2">More...</a><br /></td></tr>
<tr class="separator:a695907e4a3ef7d0e9ab34f5afff709b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadd57241c497cbe1a2ce5ac57549080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#adadd57241c497cbe1a2ce5ac57549080">all_of</a></td></tr>
<tr class="memdesc:adadd57241c497cbe1a2ce5ac57549080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all the keys of the structure satisfy the <code>predicate</code>.  <a href="#adadd57241c497cbe1a2ce5ac57549080">More...</a><br /></td></tr>
<tr class="separator:adadd57241c497cbe1a2ce5ac57549080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a67dd29f7921b76f7d2bd372605f73f7c">any</a></td></tr>
<tr class="memdesc:a67dd29f7921b76f7d2bd372605f73f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any key of the structure is true-valued.  <a href="#a67dd29f7921b76f7d2bd372605f73f7c">More...</a><br /></td></tr>
<tr class="separator:a67dd29f7921b76f7d2bd372605f73f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc05dc4553467aa0a2235088de41b4b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a2dc05dc4553467aa0a2235088de41b4b">any_of</a></td></tr>
<tr class="memdesc:a2dc05dc4553467aa0a2235088de41b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether any key of the structure satisfies the <code>predicate</code>.  <a href="#a2dc05dc4553467aa0a2235088de41b4b">More...</a><br /></td></tr>
<tr class="separator:a2dc05dc4553467aa0a2235088de41b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98adce2584ff5cb8a19ea2a74d5bb34"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#ae98adce2584ff5cb8a19ea2a74d5bb34">at_key</a></td></tr>
<tr class="memdesc:ae98adce2584ff5cb8a19ea2a74d5bb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated to the given key in a structure, or fail.  <a href="#ae98adce2584ff5cb8a19ea2a74d5bb34">More...</a><br /></td></tr>
<tr class="separator:ae98adce2584ff5cb8a19ea2a74d5bb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4a67c4fd522de62b101ed99bb423e3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a1b4a67c4fd522de62b101ed99bb423e3">contains</a></td></tr>
<tr class="memdesc:a1b4a67c4fd522de62b101ed99bb423e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the key occurs in the structure.  <a href="#a1b4a67c4fd522de62b101ed99bb423e3">More...</a><br /></td></tr>
<tr class="separator:a1b4a67c4fd522de62b101ed99bb423e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234e4ee0bd5e0e9e604d6140fde24074"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a234e4ee0bd5e0e9e604d6140fde24074">in</a> = hana::infix(hana::flip(hana::contains))</td></tr>
<tr class="memdesc:a234e4ee0bd5e0e9e604d6140fde24074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the key occurs in the structure.  <a href="#a234e4ee0bd5e0e9e604d6140fde24074">More...</a><br /></td></tr>
<tr class="separator:a234e4ee0bd5e0e9e604d6140fde24074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a></td></tr>
<tr class="memdesc:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value associated to the given key in a structure.  <a href="#a2772d97163d2e2ca3f51b2d16d13ff66">More...</a><br /></td></tr>
<tr class="separator:a2772d97163d2e2ca3f51b2d16d13ff66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade889e960898a96ac6502c9301827220"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a></td></tr>
<tr class="memdesc:ade889e960898a96ac6502c9301827220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the value associated to the first key satisfying a predicate.  <a href="#ade889e960898a96ac6502c9301827220">More...</a><br /></td></tr>
<tr class="separator:ade889e960898a96ac6502c9301827220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d02fba3a74d476e179b4d9d8be6b6bb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a8d02fba3a74d476e179b4d9d8be6b6bb">is_disjoint</a></td></tr>
<tr class="memdesc:a8d02fba3a74d476e179b4d9d8be6b6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether two <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s are disjoint.  <a href="#a8d02fba3a74d476e179b4d9d8be6b6bb">More...</a><br /></td></tr>
<tr class="separator:a8d02fba3a74d476e179b4d9d8be6b6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386ac8af7123ea1e8ea1fa2bbd4cbf3d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a386ac8af7123ea1e8ea1fa2bbd4cbf3d">is_subset</a></td></tr>
<tr class="memdesc:a386ac8af7123ea1e8ea1fa2bbd4cbf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a structure contains a subset of the keys of another structure.  <a href="#a386ac8af7123ea1e8ea1fa2bbd4cbf3d">More...</a><br /></td></tr>
<tr class="separator:a386ac8af7123ea1e8ea1fa2bbd4cbf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9365b793fe547271e48fa719a7f4854d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#a9365b793fe547271e48fa719a7f4854d">none</a></td></tr>
<tr class="memdesc:a9365b793fe547271e48fa719a7f4854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all of the keys of the structure are false-valued.  <a href="#a9365b793fe547271e48fa719a7f4854d">More...</a><br /></td></tr>
<tr class="separator:a9365b793fe547271e48fa719a7f4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1Searchable.html#abf1dbf83a1d98c62994e207ea18eea8a">none_of</a></td></tr>
<tr class="memdesc:abf1dbf83a1d98c62994e207ea18eea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether none of the keys of the structure satisfy the <code>predicate</code>.  <a href="#abf1dbf83a1d98c62994e207ea18eea8a">More...</a><br /></td></tr>
<tr class="separator:abf1dbf83a1d98c62994e207ea18eea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="a695907e4a3ef7d0e9ab34f5afff709b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether all the keys of the structure are true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s. If the structure is not finite, a false-valued key must appear at a finite "index" in order for this method to finish.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all_8hpp.html">boost/hana/all.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::all(hana::make_tuple(hana::true_c, <span class="keyword">true</span>, hana::true_c)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::all(hana::make_tuple(<span class="keyword">true</span>, hana::false_c, hana::true_c)));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="adadd57241c497cbe1a2ce5ac57549080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto all_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether all the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a false- valued <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="all__of_8hpp.html">boost/hana/all_of.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rem_8hpp.html">boost/hana/rem.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::all_of(hana::make_tuple(1, 3), is_odd));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::all_of(hana::make_tuple(3_c, 4_c), is_odd));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::all_of(</div>
<div class="line">        hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_void&gt;</div>
<div class="line">    ));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::all_of(</div>
<div class="line">        hana::make_tuple(hana::type_c&lt;int&gt;, hana::type_c&lt;char&gt;), hana::trait&lt;std::is_integral&gt;</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a67dd29f7921b76f7d2bd372605f73f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether any key of the structure is true-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="any_8hpp.html">boost/hana/any.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::any(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::true_c)));</div>
<div class="line">static_assert(hana::any(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, <span class="keyword">true</span>)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!hana::any(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::false_c)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2dc05dc4553467aa0a2235088de41b4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto any_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether any key of the structure satisfies the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to be satisfied after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="any__of_8hpp.html">boost/hana/any_of.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type__traits_8hpp.html">boost/hana/ext/std/type_traits.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rem_8hpp.html">boost/hana/rem.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::any_of(hana::make_tuple(1, 2), is_odd));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::any_of(hana::make_tuple(2_c, 4_c), is_odd));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::any_of(</div>
<div class="line">        hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_void&gt;</div>
<div class="line">    ));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::any_of(</div>
<div class="line">        hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_integral&gt;</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae98adce2584ff5cb8a19ea2a74d5bb34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto at_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; key) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns the value associated to the given key in a structure, or fail. </p>
<p>Given a <code>key</code> and a <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> structure, <code>at_key</code> returns the first value whose key is equal to the given <code>key</code>, and fails at compile-time if no such key exists. This requires the <code>key</code> to be compile-time <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code>, exactly like for <code>find</code>. <code>at_key</code> satisfies the following: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#ae98adce2584ff5cb8a19ea2a74d5bb34">at_key</a>(xs, key) == from_just(<a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(xs, key))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="at__key_8hpp.html">boost/hana/at_key.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> m = hana::make_map(</div>
<div class="line">        hana::make_pair(hana::type_c&lt;int&gt;, std::string{<span class="stringliteral">&quot;int&quot;</span>}),</div>
<div class="line">        hana::make_pair(hana::int_c&lt;3&gt;, std::string{<span class="stringliteral">&quot;3&quot;</span>})</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::at_key(m, hana::type_c&lt;int&gt;) == <span class="stringliteral">&quot;int&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// usage as operator[]</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(m[hana::type_c&lt;int&gt;] == <span class="stringliteral">&quot;int&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(m[hana::int_c&lt;3&gt;] == <span class="stringliteral">&quot;3&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a1b4a67c4fd522de62b101ed99bb423e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto contains</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; key) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether the key occurs in the structure. </p>
<p>Specifically, returns whether any of the keys of the structure is equal to the given <code>key</code>. If the structure is not finite, an equal key has to appear at a finite "index" in the structure for this method to finish. For convenience, <code>contains</code> can also be applied in infix notation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> with the other keys of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="contains_8hpp.html">boost/hana/contains.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::contains(hana::make_tuple(2, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>), hana::int_c&lt;3&gt;));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::contains(hana::make_set(hana::int_c&lt;3&gt;, hana::type_c&lt;void&gt;), hana::type_c&lt;void&gt;));</div>
<div class="line"></div>
<div class="line"><span class="comment">// contains can be applied in infix notation</span></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::make_tuple(2, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>) ^hana::contains^ hana::int_c&lt;2&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a234e4ee0bd5e0e9e604d6140fde24074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto in = hana::infix(hana::flip(hana::contains))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether the key occurs in the structure. </p>
<p>Specifically, this is equivalent to <code>contains</code>, except <code>in</code> takes its arguments in reverse order. Like<code>contains</code>, <code>in</code> can also be applied in infix notation for increased expressiveness. This function is not a method that can be overriden; it is just a convenience function provided with the concept.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="contains_8hpp.html">boost/hana/contains.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::int_c&lt;2&gt; ^hana::in^ hana::make_tuple(2, hana::int_c&lt;2&gt;, hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2772d97163d2e2ca3f51b2d16d13ff66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; key) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Finds the value associated to the given key in a structure. </p>
<p>Given a <code>key</code> and a <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> structure, <code>find</code> returns the <code>just</code> the first value whose key is equal to the given <code>key</code>, or <code>nothing</code> if there is no such key. Comparison is done with <code>equal</code>. <code>find</code> satisfies the following: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1Searchable.html#a2772d97163d2e2ca3f51b2d16d13ff66">find</a>(xs, key) == <a class="code" href="structboost_1_1hana_1_1Searchable.html#ade889e960898a96ac6502c9301827220">find_if</a>(xs, equal.to(key))</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">key</td><td>A key to be searched for in the structure. The key has to be <code><a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a></code> with the other keys of the structure. In the current version of the library, the comparison of <code>key</code> with any other key of the structure must return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find_8hpp.html">boost/hana/find.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::find(hana::make_tuple(hana::int_c&lt;1&gt;, hana::type_c&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), hana::type_c&lt;int&gt;) == hana::just(hana::type_c&lt;int&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::find(hana::make_tuple(hana::int_c&lt;1&gt;, hana::type_c&lt;int&gt;, <span class="charliteral">&#39;3&#39;</span>), hana::type_c&lt;void&gt;) == hana::nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> m = hana::make_map(</div>
<div class="line">    hana::make_pair(hana::int_c&lt;2&gt;, 2),</div>
<div class="line">    hana::make_pair(hana::type_c&lt;float&gt;, 3.3),</div>
<div class="line">    hana::make_pair(hana::type_c&lt;char&gt;, hana::type_c&lt;int&gt;)</div>
<div class="line">);</div>
<div class="line">static_assert(hana::find(m, hana::type_c&lt;float&gt;) == hana::just(3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ade889e960898a96ac6502c9301827220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto find_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Finds the value associated to the first key satisfying a predicate. </p>
<p>Specifically, returns <code>just</code> the first value whose key satisfies the <code>predicate</code>, or <code>nothing</code> if there is no such key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to be searched.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>. Note that in the current version of the library, the <code>predicate</code> has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> because <code>find_if</code> returns either a <code>just(...)</code> or <code>nothing</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="find__if_8hpp.html">boost/hana/find_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::find_if(hana::make_tuple(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), hana::trait&lt;std::is_integral&gt;) == hana::just(2)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::find_if(hana::make_tuple(1.0, 2, <span class="charliteral">&#39;3&#39;</span>), hana::trait&lt;std::is_class&gt;) == hana::nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;char, int, unsigned, long, unsigned long&gt;;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::find_if(types, hana::equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;unsigned&gt;)) == hana::just(hana::type_c&lt;unsigned&gt;)</div>
<div class="line">);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    hana::find_if(types, hana::equal.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;void&gt;)) == hana::nothing</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.find_if.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a8d02fba3a74d476e179b4d9d8be6b6bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto is_disjoint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; ys) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether two <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s are disjoint. </p>
<p>Given two <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s <code>xs</code> and <code>ys</code>, <code>is_disjoint</code> returns a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether the keys in <code>xs</code> are disjoint from the keys in <code>ys</code>, i.e. whether both structures have no keys in common.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s to test for disjointness.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__disjoint_8hpp.html">boost/hana/is_disjoint.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="map_8hpp.html">boost/hana/map.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="set_8hpp.html">boost/hana/set.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Tuples</span></div>
<div class="line">    <span class="keyword">auto</span> xs = hana::make_tuple(hana::int_c&lt;1&gt;, <span class="stringliteral">&quot;alfa&quot;</span>s, hana::type_c&lt;int&gt;);</div>
<div class="line">    <span class="keyword">auto</span> ys = hana::make_tuple(hana::type_c&lt;void&gt;, hana::int_c&lt;3&gt;, <span class="stringliteral">&quot;bravo&quot;</span>s);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(hana::is_disjoint(xs, ys));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Sets</span></div>
<div class="line">    <span class="keyword">auto</span> s1 = hana::make_set(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;, hana::int_c&lt;2&gt;);</div>
<div class="line">    <span class="keyword">auto</span> s2 = hana::make_set(hana::type_c&lt;char&gt;, hana::type_c&lt;int&gt;, hana::int_c&lt;1&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::is_disjoint(s1, s2));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Maps</span></div>
<div class="line">    <span class="keyword">auto</span> vowels = hana::make_map(</div>
<div class="line">        hana::make_pair(hana::char_c&lt;&#39;a&#39;&gt;, <span class="stringliteral">&quot;alfa&quot;</span>s),</div>
<div class="line">        hana::make_pair(hana::char_c&lt;&#39;e&#39;&gt;, <span class="stringliteral">&quot;echo&quot;</span>s),</div>
<div class="line">        hana::make_pair(hana::char_c&lt;&#39;i&#39;&gt;, <span class="stringliteral">&quot;india&quot;</span>s)</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> consonants = hana::make_map(</div>
<div class="line">        hana::make_pair(hana::char_c&lt;&#39;b&#39;&gt;, <span class="stringliteral">&quot;bravo&quot;</span>s),</div>
<div class="line">        hana::make_pair(hana::char_c&lt;&#39;c&#39;&gt;, <span class="stringliteral">&quot;charlie&quot;</span>s),</div>
<div class="line">        hana::make_pair(hana::char_c&lt;&#39;f&#39;&gt;, <span class="stringliteral">&quot;foxtrot&quot;</span>s)</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::is_disjoint(vowels, consonants));</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.is_disjoint.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a386ac8af7123ea1e8ea1fa2bbd4cbf3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto is_subset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether a structure contains a subset of the keys of another structure. </p>
<p>Given two <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s <code>xs</code> and <code>ys</code>, <code>is_subset</code> returns a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether <code>xs</code> is a subset of <code>ys</code>. In other words, it returns whether all the keys of <code>xs</code> are also present in <code>ys</code>. This method does not return whether <code>xs</code> is a <em>strict</em> subset of <code>ys</code>; if <code>xs</code> and <code>ys</code> are equal, all the keys of <code>xs</code> are also present in <code>ys</code>, and <code>is_subset</code> returns true.</p>
<dl class="section note"><dt>Note</dt><dd>For convenience, <code>is_subset</code> can also be applied in infix notation.</dd></dl>
<h2>Cross-type version of the method </h2>
<p>This method is tag-dispatched using the data type of both arguments. It can be called with any two <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s sharing a common <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> embedding, as defined in the main documentation of the <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> concept. When <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s of two different data types but sharing a common embedding are sent to <code>is_subset</code>, they are first converted to this common <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> and the <code>is_subset</code> method of the common embedding is then used. Of course, the method can be overriden for custom <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code>s for efficieny.</p>
<dl class="section note"><dt>Note</dt><dd>While cross-type dispatching for <code>is_subset</code> is supported, it is not currently used by the library because there are no models of <code><a class="el" href="structboost_1_1hana_1_1Searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a></code> with a common embedding.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to check whether it is a subset of <code>ys</code>.</td></tr>
    <tr><td class="paramname">ys</td><td>The structure to check whether it is a superset of <code>xs</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="is__subset_8hpp.html">boost/hana/is_subset.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    hana::is_subset(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), hana::make_tuple(3.3, 1, <span class="charliteral">&#39;2&#39;</span>, <span class="keyword">nullptr</span>))</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// is_subset can be applied in infix notation</span></div>
<div class="line">static_assert(</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) ^hana::is_subset^ hana::make_tuple(3.3, 1, <span class="charliteral">&#39;2&#39;</span>, <span class="keyword">nullptr</span>)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --><h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.is_subset.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a9365b793fe547271e48fa719a7f4854d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether all of the keys of the structure are false-valued. </p>
<p>The keys of the structure must be <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>s. If the structure is not finite, a true-valued key must appear at a finite "index" in order for this method to finish.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="none_8hpp.html">boost/hana/none.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">static_assert(hana::none(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::false_c)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!hana::none(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, <span class="keyword">true</span>)), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(!hana::none(hana::make_tuple(<span class="keyword">false</span>, hana::false_c, hana::true_c)));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="abf1dbf83a1d98c62994e207ea18eea8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto none_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Returns whether none of the keys of the structure satisfy the <code>predicate</code>. </p>
<p>If the structure is not finite, <code>predicate</code> has to return a true- valued <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> after looking at a finite number of keys for this method to finish.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to search.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(k)</code>, where <code>k</code> is a key of the structure, and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">@copyright Louis Dionne 2015</span></div>
<div class="line"><span class="comment">Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="none__of_8hpp.html">boost/hana/none_of.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not_8hpp.html">boost/hana/not.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="rem_8hpp.html">boost/hana/rem.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::none_of(hana::make_tuple(2_c, 4_c), is_odd));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(!hana::none_of(hana::make_tuple(1, 2), is_odd));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        !hana::none_of(hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_void&gt;)</div>
<div class="line">    );</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::none_of(hana::make_tuple(hana::type_c&lt;void&gt;, hana::type_c&lt;char&amp;&gt;), hana::trait&lt;std::is_integral&gt;)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1Searchable.html">Searchable</a></li>
  </ul>
</div>
</body>
</html>
