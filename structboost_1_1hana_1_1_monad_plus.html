<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::MonadPlus Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1_monad_plus.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of methods</a> &#124;
<a href="structboost_1_1hana_1_1_monad_plus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::MonadPlus Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> concept represents Monads with a monoidal structure. </p>
<p>Intuitively, whereas a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> can be seen as some kind of container or context, a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> can be seen as a container or a context that can be concatenated with other containers or contexts. There must also be an identity element for this combining operation. For example, a <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> is a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, because tuples can be concatenated and the empty tuple would act as an identity for concatenation. How is this different from a <a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> which is also a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>? The answer is that the monoidal structure on a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> must <em>not</em> depend of the contents of the structure; it must not require the contents to be a <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> in order to work.</p>
<p>While sequences are not the only possible model for <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, the method names used here refer to the <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> of sequences under concatenation. Several useful functions generalizing operations on sequences are included with this concept, like <code>append</code>, <code>prepend</code> and <code>filter</code>.</p>
<h2>Superclasses </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="structboost_1_1hana_1_1_applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> and <code><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code></p>
<h2>Minimal complete definition </h2>
<p><code>concat</code> and <code>empty</code></p>
<h2>Laws </h2>
<p>First, a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> is required to have a monoidal structure. Hence, it is no surprise that for any <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, we require <code>M(T)</code> to be a valid monoid. However, we do not enforce that <code>M(T)</code> actually models the <a class="el" href="structboost_1_1hana_1_1_monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> concept provided by Hana. Further, for all objects <code>a, b, c</code> of data type <code>M(T)</code>, </p><div class="fragment"><div class="line"><span class="comment">// identity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;(), a) == a</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(a, <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;()) == a</div>
<div class="line"></div>
<div class="line"><span class="comment">// associativity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(a, <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(b, c)) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(a, b), c)</div>
</div><!-- fragment --><p>Second, a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> is also required to obey the following laws, which represent the fact that <code>empty&lt;M(T)&gt;()</code> must be some kind of absorbing element for the <code>bind</code> operation. For all objects <code>a</code> of data type <code>M(T)</code> and functions <img class="formulaInl" alt="$ f : T \to M(U) $" src="form_19.png"/>, </p><div class="fragment"><div class="line">bind(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;(), f)         == empty&lt;M(U)&gt;()</div>
<div class="line">bind(a, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;())) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(U)&gt;()</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of methods</h2></td></tr>
<tr class="memitem:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a></td></tr>
<tr class="memdesc:a30a6926751dfcafbe2bb67738e2da3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two monadic structures together.  <a href="#a30a6926751dfcafbe2bb67738e2da3c4">More...</a><br /></td></tr>
<tr class="separator:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ad3cf817440c20f200f91d4fa4e789"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a91ad3cf817440c20f200f91d4fa4e789"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a></td></tr>
<tr class="memdesc:a91ad3cf817440c20f200f91d4fa4e789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity of the monadic combination <code>concat</code>.  <a href="#a91ad3cf817440c20f200f91d4fa4e789">More...</a><br /></td></tr>
<tr class="separator:a91ad3cf817440c20f200f91d4fa4e789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e173a5524274624703353bb3ac4c129"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a></td></tr>
<tr class="memdesc:a3e173a5524274624703353bb3ac4c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to a monadic structure.  <a href="#a3e173a5524274624703353bb3ac4c129">More...</a><br /></td></tr>
<tr class="separator:a3e173a5524274624703353bb3ac4c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae469094a7fee3a0f7dfcc900da9b07b4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a></td></tr>
<tr class="memdesc:ae469094a7fee3a0f7dfcc900da9b07b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to a monadic structure.  <a href="#ae469094a7fee3a0f7dfcc900da9b07b4">More...</a><br /></td></tr>
<tr class="separator:ae469094a7fee3a0f7dfcc900da9b07b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929370eddd43bb1a4a11b00a7880eadb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a></td></tr>
<tr class="memdesc:a929370eddd43bb1a4a11b00a7880eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a monadic structure using a custom predicate.  <a href="#a929370eddd43bb1a4a11b00a7880eadb">More...</a><br /></td></tr>
<tr class="separator:a929370eddd43bb1a4a11b00a7880eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cd26f8259bdd4306cd0907ef578b47"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a></td></tr>
<tr class="memdesc:a15cd26f8259bdd4306cd0907ef578b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a monadic structure with itself <code>n</code> times.  <a href="#a15cd26f8259bdd4306cd0907ef578b47">More...</a><br /></td></tr>
<tr class="separator:a15cd26f8259bdd4306cd0907ef578b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#acbf4797cf95bb19dfe33a16cf86fe3c9">repeat</a></td></tr>
<tr class="memdesc:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a monadic structure by combining a lifted value with itself <code>n</code> times.  <a href="#acbf4797cf95bb19dfe33a16cf86fe3c9">More...</a><br /></td></tr>
<tr class="separator:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ba602a660bdb3bbeb43cc600de3008"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a85ba602a660bdb3bbeb43cc600de3008">prefix</a></td></tr>
<tr class="memdesc:a85ba602a660bdb3bbeb43cc600de3008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value before each element of a monadic structure.  <a href="#a85ba602a660bdb3bbeb43cc600de3008">More...</a><br /></td></tr>
<tr class="separator:a85ba602a660bdb3bbeb43cc600de3008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6622ade385d42bf03dd18f226cd080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html#a9b6622ade385d42bf03dd18f226cd080">suffix</a></td></tr>
<tr class="memdesc:a9b6622ade385d42bf03dd18f226cd080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value after each element of a monadic structure.  <a href="#a9b6622ade385d42bf03dd18f226cd080">More...</a><br /></td></tr>
<tr class="separator:a9b6622ade385d42bf03dd18f226cd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Methods</h2>
<a class="anchor" id="a30a6926751dfcafbe2bb67738e2da3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto concat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine two monadic structures together. </p>
<p>Given two monadic structures, <code>concat</code> combines them together and returns a new monadic structure. The exact definition of <code>concat</code> will depend on the exact model of <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> at hand, but for sequences it corresponds intuitively to simple concatenation.</p>
<p>Also note that combination is not required to be commutative. In other words, there is no requirement that </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, ys) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(ys, xs)</div>
</div><!-- fragment --><p> , and it does not hold in general.</p>
<h2>Signature </h2>
<p>Given <code>M</code> a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, the signature is <img class="formulaInl" alt="$ \mathrm{concat} : M(T) \times M(T) \to M(T) $" src="form_20.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two monadic structures to combine together.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>), make&lt;Tuple&gt;(3.3, 4_c)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91ad3cf817440c20f200f91d4fa4e789"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Identity of the monadic combination <code>concat</code>. </p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{empty}_M : \emptyset \to M(T) $" src="form_48.png"/>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The data type of the monadic structure to return. This must be a model of the <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(empty&lt;Tuple&gt;() == make&lt;Tuple&gt;());</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(empty&lt;Maybe&gt;() == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3e173a5524274624703353bb3ac4c129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto prepend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Prepend an element to a monadic structure. </p>
<p>Given an element <code>x</code> and a monadic structure <code>xs</code>, <code>prepend</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the left) with <code>xs</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(x, xs) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(lift&lt;Xs&gt;(x), xs)</div>
</div><!-- fragment --><p>For sequences, this has the intuitive behavior of simply prepending an element to the beginning of the sequence, hence the name.</p>
<blockquote class="doxtable">
<h4>Rationale for not calling this <code>push_front</code></h4>
<p>While <code>push_front</code> is the de-facto name used in the standard library, it also strongly suggests mutation of the underlying sequence, which is not the case here. The author also finds that <code>push_front</code> suggests too strongly the sole interpretation of putting an element to the front of a sequence, whereas <code>prepend</code> is slightly more nuanced and bears its name better for e.g. <code><a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a></code>. </p>
</blockquote>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{prepend} : T \times M(T) \to M(T) $" src="form_23.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>An element to combine to the left of the monadic structure.</td></tr>
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the right of the element.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(1, make&lt;Tuple&gt;()) == make&lt;Tuple&gt;(1));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(1, make&lt;Tuple&gt;(<span class="charliteral">&#39;2&#39;</span>, 3.3)) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(1, <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(<span class="charliteral">&#39;2&#39;</span>, <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(3.3, make&lt;Tuple&gt;()))) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae469094a7fee3a0f7dfcc900da9b07b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto append</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Append an element to a monadic structure. </p>
<p>Given an element <code>x</code> of data typeÂ <code>X</code> and a monadic structure <code>xs</code> containing objects of data type <code>X</code>, <code>append</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the right) with <code>xs</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(xs, x) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, lift&lt;Xs&gt;(x))</div>
</div><!-- fragment --><p>For sequences, this has the intuitive behavior of simply appending an element to the end of the sequence, hence the name.</p>
<blockquote class="doxtable">
<h4>Rationale for not calling this <code>push_back</code></h4>
<p>See the rationale for using <code>prepend</code> instead of <code>push_front</code>. </p>
</blockquote>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{append} : M(T) \times T \to M(T) $" src="form_24.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the left of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the right of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(make&lt;Tuple&gt;(), 1) == make&lt;Tuple&gt;(1));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(make&lt;Tuple&gt;(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == make&lt;Tuple&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a929370eddd43bb1a4a11b00a7880eadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; pred) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Filter a monadic structure using a custom predicate. </p>
<p>Given a monadic structure and a predicate, <code>filter</code> returns a new monadic structure containing only those elements that satisfy the predicate. This is a generalization of the usual <code>filter</code> function for sequences; it works for any <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>. Intuitively, <code>filter</code> is somewhat equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(xs, pred) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> pred(x) ? lift&lt;Xs&gt;(x) : empty&lt;Xs&gt;();</div>
<div class="line">})</div>
</div><!-- fragment --><p> In other words, we basically turn a monadic structure containing <code>[x1, ..., xn]</code> into a monadic structure containing </p><div class="fragment"><div class="line">[</div>
<div class="line">    pred(x1) ? [x1] : [],</div>
<div class="line">    pred(x2) ? [x2] : [],</div>
<div class="line">    ...</div>
<div class="line">    pred(xn) ? [xn] : []</div>
<div class="line">]</div>
</div><!-- fragment --><p> , and we then <code>flatten</code> that.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code> and a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code>, the signature is <img class="formulaInl" alt="$ \mathrm{filter} : M(T) \times (T \to \mathrm{Bool}) \to M(T) $" src="form_29.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The monadic structure to filter.</td></tr>
    <tr><td class="paramname">pred</td><td>A function called as <code>pred(x)</code> for each element <code>x</code> in the monadic structure and returning a <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether that element should be <b>kept</b> in the resulting structure. In the current version of the library, the predicate has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(make&lt;Tuple&gt;(1, 2.0, 3, 4.0), trait_&lt;std::is_integral&gt;) == make&lt;Tuple&gt;(1, 3)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(just(3), trait_&lt;std::is_integral&gt;) == just(3)</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(just(3.0), trait_&lt;std::is_integral&gt;) == nothing</div>
<div class="line">);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="image">
<img src="benchmark/monad_plus/filter.ctime.png" alt="filter.ctime.png"/>
</div>
 
</div>
</div>
<a class="anchor" id="a15cd26f8259bdd4306cd0907ef578b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cycle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine a monadic structure with itself <code>n</code> times. </p>
<p>Given a non-negative number <code>n</code> and a monadic structure <code>xs</code>, <code>cycle</code> returns a new monadic structure which is the result of combining <code>xs</code> with itself <code>n</code> times using the <code>concat</code> operation. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(n, xs) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, ... <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, xs)))</div>
<div class="line">                                  <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>Also note that since <code>concat</code> is required to be associative, we could also have written </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(n, xs) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(... <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, xs), xs), xs)</div>
<div class="line">                          <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of <code>concat</code>, <code>empty</code>, is returned. In the case of sequences, this boils down to returning a sequence which containes <code>n</code> copies of itself; for other models it might differ.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <code>C</code> and a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{cycle} : C \times M(T) \to M(T) $" src="form_27.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the number of times to combine the monadic structure with itself. If <code>n</code> is zero, <code>cycle</code> returns <code>empty</code>.</td></tr>
    <tr><td class="paramname">xs</td><td>A monadic structure to combine with itself a certain number of times.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(size_t&lt;2&gt;, make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>)) == make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;z&#39;</span>)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acbf4797cf95bb19dfe33a16cf86fe3c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto repeat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; n, <span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create a monadic structure by combining a lifted value with itself <code>n</code> times. </p>
<p>Given a non-negative number <code>n</code>, a value <code>x</code> and a monadic data type <code>M</code>, <code>repeat</code> creates a new monadic structure which is the result of combining <code>x</code> with itself <code>n</code> times inside the monadic structure. In other words, <code>repeat</code> simply <code>lift</code>s <code>x</code> into the monadic structure, and then combines that with itself <code>n</code> times: </p><div class="fragment"><div class="line">repeat&lt;M&gt;(n, x) == <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(n, lift&lt;M&gt;(x))</div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of the <code>concat</code> operation is returned. In the case of sequences, this corresponds to creating a new sequence holding <code>n</code> copies of <code>x</code>.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a> <code>C</code> and <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{repeat}_M : C \times T \to M(T) $" src="form_49.png"/>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The data type of the returned monadic structure. It must be a model of the <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant type class represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the number of times to combine <code>lift&lt;M&gt;(x)</code> with itself. If <code>n == 0</code>, then <code>repeat</code> returns <code>empty&lt;M&gt;()</code>.</td></tr>
    <tr><td class="paramname">x</td><td>The value to lift into a monadic structure and then combine with itself.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(repeat&lt;Tuple&gt;(size_t&lt;2&gt;, <span class="charliteral">&#39;x&#39;</span>) == make&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Of course, because Maybe can hold at most one element.</span></div>
<div class="line">static_assert(repeat&lt;Maybe&gt;(size_t&lt;2&gt;, <span class="charliteral">&#39;x&#39;</span>) == just(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a85ba602a660bdb3bbeb43cc600de3008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto prefix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; z, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value before each element of a monadic structure. </p>
<p>Given a value (called the prefix) <code>z</code> and a monadic structure <code>xs</code>, <code>prefix</code> returns a new monadic structure which is equivalent to </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a85ba602a660bdb3bbeb43cc600de3008">prefix</a>(z, xs) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(lift&lt;M&gt;(z), lift&lt;M&gt;(x));</div>
<div class="line">}))</div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the prefix before each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>prefix</code> will return </p><div class="fragment"><div class="line">[z, x1, z, x2, ..., z, xn]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> models, with various levels of interest.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{prefix} : T \times M(T) \to M(T) $" src="form_30.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A value (the prefix) to insert before each element of a monadic structure.</td></tr>
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a85ba602a660bdb3bbeb43cc600de3008">prefix</a>(<span class="stringliteral">&quot;my&quot;</span>s, make&lt;Tuple&gt;(<span class="stringliteral">&quot;dog&quot;</span>s, <span class="stringliteral">&quot;car&quot;</span>s, <span class="stringliteral">&quot;house&quot;</span>s)) ==</div>
<div class="line">    make&lt;Tuple&gt;(<span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;car&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;house&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b6622ade385d42bf03dd18f226cd080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto suffix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; z, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value after each element of a monadic structure. </p>
<p>Given a value (called the suffix) <code>z</code> and a monadic structure <code>xs</code>, <code>suffix</code> returns a new monadic structure which is equivalent to </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a9b6622ade385d42bf03dd18f226cd080">suffix</a>(z, xs) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(lift&lt;M&gt;(x), lift&lt;M&gt;(z));</div>
<div class="line">}))</div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the suffix after each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>suffix</code> will return </p><div class="fragment"><div class="line">[x1, z, x2, z, ..., xn, z]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> models, with various levels of interest.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is <img class="formulaInl" alt="$ \mathrm{suffix} : T \times M(T) \to M(T) $" src="form_31.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>A value (the suffix) to insert after each element of a monadic structure.</td></tr>
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1_monad_plus.html#a9b6622ade385d42bf03dd18f226cd080">suffix</a>(0, make&lt;Tuple&gt;(1, 2, 3, 4)) == make&lt;Tuple&gt;(1, 0, 2, 0, 3, 0, 4, 0)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html">MonadPlus</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
