<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript">
  window.onload = function() {
    $(".benchmark-chart").each(function(index, div) {
      var compiler = "clang-3.5.0";
      var dataset = div.getAttribute("data-dataset");
      var repo = "https://rawgit.com/ldionne/hana/datasets/release/";
      $.getJSON(repo + compiler + "/" + dataset, function(options) {
        Hana.initChart($(div), options);
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a></li>
<li class="level1"><a href="#tutorial-introduction">Introduction</a></li>
<li class="level1"><a href="#tutorial-quickstart">Quick start</a><ul><li class="level2"><a href="#tutorial-quickstart-cheatsheet">Cheatsheet</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-create">Creating sequences</a></li>
<li class="level1"><a href="#tutorial-assert">Assertions</a></li>
<li class="level1"><a href="#tutorial-sem">Algorithm semantics</a></li>
<li class="level1"><a href="#tutorial-amphi">Amphibian algorithms</a></li>
<li class="level1"><a href="#tutorial-type">Type computations</a></li>
<li class="level1"><a href="#tutorial-perf">Performance considerations</a><ul><li class="level2"><a href="#tutorial-perf-compile">Compile-time performance</a></li>
<li class="level2"><a href="#tutorial-perf-runtime">Runtime performance</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-constexpr">The limitations of constexpr</a><ul><li class="level2"><a href="#tutorial-constexpr-constants">Constants</a></li>
<li class="level2"><a href="#tutorial-constexpr-side_effects">Side effects</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-hetero">Heterogeneity and generalized types</a></li>
<li class="level1"><a href="#tutorial-ext">Integration with external libraries</a><ul><li class="level2"><a href="#tutorial-ext-std">The standard library</a></li>
<li class="level2"><a href="#tutorial-ext-fusion">Boost.Fusion</a></li>
<li class="level2"><a href="#tutorial-ext-mpl">Boost.MPL</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-extending">Extending the library</a><ul><li class="level2"><a href="#tutorial-extending-tag_dispatching">Tag dispatching</a></li>
<li class="level2"><a href="#tutorial-extending-creating_concepts">Creating new concepts</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-header_organization">Header organization</a></li>
<li class="level1"><a href="#tutorial-using_the_reference">Using the reference</a><ul><li class="level2"><a href="#tutorial-using_the_reference-pseudo">Pseudo-code glossary</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-rationales">Rationales/FAQ</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> The seed that became this library was planted in late 2012, when I first started to reimplement the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> using C++11 in a project named <a href="http://github.com/ldionne/mpl11">MPL11</a>. In spring 2014, I applied to <a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2014">Google Summer of Code</a> with that project for the Boost organization and got in. The goal was to polish the MPL11 and get it in Boost by the end of the summer. In May, before GSoC was started full steam, I presented the project at <a href="http://cppnow.org">C++Now</a> and had insightful conversations with several attendees. The idea that it was possible to unify the <a href="http://www.boost.org/doc/libs/release/libs/fusion/doc/html/index.html">Boost.Fusion</a> and the <a href="http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html">Boost.MPL</a> libraries made its way and I became convinced of it after writing the first prototype for what is now Boost.Hana. After working on Hana and polishing many rough edges during several months, Hana will be going through formal review for inclusion in Boost from June 10 2015 to June 24 2015.</p>
<p>Let the fun begin!</p>
<h1><a class="anchor" id="tutorial-introduction"></a>
Introduction</h1>
<hr/>
<p> Hana is a header-only library for C++ metaprogramming suited for computations on both types and values. The functionality it provides is a superset of what is provided by the well established Boost.MPL and Boost.Fusion libraries. By leveraging C++11/14 implementation techniques and idioms, Hana boasts faster compilation times and runtime performance on par or better than previous metaprogramming libraries, while noticeably increasing the level of expressiveness in the process. Hana is easy to extend in a ad-hoc manner and it provides out-of-the-box inter-operation with Boost.Fusion, Boost.MPL and the standard library.</p>
<p><b>Motivation</b><br />
When Boost.MPL first appeared, it provided C++ programmers with a huge relief by abstracting tons of template hackery behind a workable interface. This breakthrough greatly contributed to making C++ template metaprogramming more mainstream, and today the discipline is deeply rooted in many serious projects. Recently, C++11 and C++14 brought many major changes to the language, some of which make metaprogramming much easier, while others drastically widen the design space for libraries. A natural question then arises: is it still desirable to have abstractions for metaprogramming, and if so, which ones? After investigating different options like the <a href="http://github.com/ldionne/mpl11">MPL11</a>, the answer eventually came by itself in the form of a library; Hana. The key insight to Hana is that the manipulation of types and values are nothing but two sides of the same coin. By unifying both concepts, metaprogramming becomes easier and new exciting possibilities open before us.</p>
<p><b>Warning: functional programming ahead</b><br />
Programming with heterogeneous objects is inherently functional &ndash; since it is impossible to modify the type of an object, a new object must be introduced instead, which rules out mutation. Unlike previous metaprogramming libraries whose design was modeled on the STL, Hana uses a functional style of programming which is the source for a good portion of its expressiveness. However, as a result, many concepts used in Hana will be unfamiliar to C++ programmers without a knowledge of FP. The documentation attempts to make these concepts approachable by using intuition whenever possible, but bear in mind that the highest rewards are usually the fruit of some effort.</p>
<h1><a class="anchor" id="tutorial-quickstart"></a>
Quick start</h1>
<hr/>
<p> This tutorial assumes the reader is already familiar with basic metaprogramming and the <a href="http://en.wikipedia.org/wiki/C%2B%2B14">C++14 standard</a>. First, let's include the library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hana_8hpp.html">boost/hana.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
</div><!-- fragment --><p> Unless specified otherwise, the documentation assumes that the above lines are present before examples and code snippets. Also note that finer grained headers are provided and will be explained in the <a class="el" href="index.html#tutorial-header_organization">Header organization</a> section. Now, let's define three simple types so we can work with them below:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person { std::string name; };</div>
<div class="line"><span class="keyword">struct </span>Car    { std::string name; };</div>
<div class="line"><span class="keyword">struct </span>City   { std::string name; };</div>
</div><!-- fragment --><p> If you are reading this documentation, chances are you already know <code>std::tuple</code> and <code>std::make_tuple</code>. Hana provides its own <code>tuple</code> and <code>make_tuple</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> stuff = make_tuple(Person{<span class="stringliteral">&quot;Louis&quot;</span>}, Car{<span class="stringliteral">&quot;Toyota&quot;</span>}, City{<span class="stringliteral">&quot;Quebec&quot;</span>});</div>
</div><!-- fragment --><p> Notice how the <code>auto</code> keyword is used when defining <code>stuff</code>; it is often useful to let the compiler deduce the type of a tuple, but sometimes it is necessary to specify it. This is of course also possible:</p>
<div class="fragment"><div class="line">_tuple&lt;Person, Car, City&gt; stuff{Person{<span class="stringliteral">&quot;Louis&quot;</span>}, Car{<span class="stringliteral">&quot;Toyota&quot;</span>}, City{<span class="stringliteral">&quot;Quebec&quot;</span>}};</div>
</div><!-- fragment --><p> Hana provides several basic operations to manipulate tuples and other kinds of heterogeneous sequences. For example, one can get the <code>n</code>th element of a tuple with <code>at_c</code> and its length with <code>length</code>, which are analogous to <code>std::get</code> and <code>std::tuple_size</code> respectively:</p>
<div class="fragment"><div class="line">Car&amp; car = at_c&lt;1&gt;(stuff);</div>
<div class="line">assert(car.name == <span class="stringliteral">&quot;Toyota&quot;</span>);</div>
<div class="line">static_assert(length(stuff) == 3u, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Notice how <code>length</code> can be used in a <code>static_assert</code> even though it is called on a non-<code>constexpr</code> tuple? Boldly, Hana makes sure that no information that's known at compile-time is lost, which is clearly the case of the tuple's size. The details are explained in the <a class="el" href="index.html#tutorial-amphi">section on amphibian algorithms</a>. Hana also provides high level algorithms to manipulate tuples and other heterogeneous containers. For example, one can apply a function to every element of a tuple and get a tuple of the results with <code>transform</code>, which is analogous to <code>std::transform</code>:</p>
<div class="fragment"><div class="line">_tuple&lt;std::string, std::string, std::string&gt; names = transform(stuff, [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> x.name; });</div>
<div class="line">assert(names == make_tuple(<span class="stringliteral">&quot;Louis&quot;</span>, <span class="stringliteral">&quot;Toyota&quot;</span>, <span class="stringliteral">&quot;Quebec&quot;</span>));</div>
</div><!-- fragment --><p> Notice how we pass a <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Generic_lambdas">C++14 generic lambda</a> to <code>transform</code>; this is required because the lambda will first be called with a <code>Person</code>, then a <code>Car</code>Â and finally a <code>City</code>, which are all different types. Hana also allows type computations to be expressed very naturally. Basically, one writes a metafunction as a generic function object as if the arguments were types:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>traits; <span class="comment">// bring in remove_cv and add_pointer</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> F = [](<span class="keyword">auto</span> T) { <span class="comment">// F is a &quot;metafunction&quot;; just pretend T is a type</span></div>
<div class="line">    <span class="keywordflow">return</span> add_pointer(remove_cv(T));</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The traits in namespace <code>boost::hana::trait</code> are in the <code>&lt;<a class="el" href="type__traits_8hpp.html" title="Defines adapters for standard components in the <type_traits> header, and also most things in the boo...">boost/hana/ext/std/type_traits.hpp</a>&gt;</code> header, which is not included by <code>&lt;<a class="el" href="hana_8hpp.html" title="Includes all the library components except the adapters for external libraries. ">boost/hana.hpp</a>&gt;</code>.</dd></dl>
<p>Then, one passes types to the function by representing them as objects using the <code>type&lt;...&gt;</code> wrapper, and everything just works:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> intp = F(type&lt;int const&gt;);</div>
<div class="line">static_assert(intp == type&lt;int*&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> This is a completely new way of doing type computations which turns out to be extremely powerful, especially for complex computations.</p>
<p>That's it for the quick start! There are many more algorithms that can be performed on sequences; they are documented by the concept to which they belong (<a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a>, <a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a>, <a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a>, <a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a>, etc...). Apart from tuples, there are also other kinds of sequences provided by Hana; they are documented in their respective page (<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>, <a class="el" href="structboost_1_1hana_1_1_range.html" title="Compile-time half-open interval of Constants. ">Range</a>, <a class="el" href="structboost_1_1hana_1_1_set.html" title="A basic unordered container requiring Comparable elements. ">Set</a>, <a class="el" href="structboost_1_1hana_1_1_map.html" title="A basic associative array requiring unique and Comparable keys. ">Map</a>, etc..). The next sections gradually introduce general concepts pertaining to Hana, but you may skip directly to the section on <a class="el" href="index.html#tutorial-type">type computations</a> if you are mostly interested by that. For quick reference, or if you want to start right away, here's a cheatsheet of the most useful functions and algorithms. Always keep in mind that the algorithms return their result as a new sequence and no in-place mutation is ever performed.</p>
<h2><a class="anchor" id="tutorial-quickstart-cheatsheet"></a>
Cheatsheet</h2>
<table class="doxtable">
<tr>
<th align="left">function </th><th align="left">concept </th><th align="left">description  </th></tr>
<tr>
<td align="left"><code>transform(sequence, f)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="left">Apply a function to each element of a sequence and return the result. </td></tr>
<tr>
<td align="left"><code>adjust_if(sequence, predicate, f)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="left">Apply a function to each element of a sequence satisfying some predicate and return the result. </td></tr>
<tr>
<td align="left"><code>adjust(sequence, value, f)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="left">Apply a function to each element of a sequence that compares equal to some value and return the result. </td></tr>
<tr>
<td align="left"><code>replace_if(sequence, predicate, newval)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="left">Replace the elements of a sequence that satisfy some predicate by some value. </td></tr>
<tr>
<td align="left"><code>replace(sequence, oldval, newval)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="left">Replace the elements of a sequence that compare equal to some value by some other value. </td></tr>
<tr>
<td align="left"><code>fill(sequence, value)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a> </td><td align="left">Replace all the elements of a sequence with some value. </td></tr>
<tr>
<td align="left"><code>fold.{left,right}(sequence[, state], f)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Accumulates the elements of a sequence from the left or right, and optionally with a provided initial state. </td></tr>
<tr>
<td align="left"><code>for_each(sequence, f)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Call a function on each element of a sequence. Returns <code>void</code>. </td></tr>
<tr>
<td align="left"><code>{length, size}(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Returns the length of a sequence as an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>{minimum, maximum}(sequence[, predicate])</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Returns the smallest/greatest element of a sequence, optionally according to a predicate. The elements must be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a> if no predicate is provided. </td></tr>
<tr>
<td align="left"><code>count_if(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Returns the number of elements that satisfy the predicate. </td></tr>
<tr>
<td align="left"><code>count(sequence, value)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Returns the number of elements that compare equal to the given value. </td></tr>
<tr>
<td align="left"><code>unpack(sequence, f)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_foldable.html" title="The Foldable concept represents data structures that can be reduced to a single value. ">Foldable</a> </td><td align="left">Calls a function with the contents of a sequence. Equivalent to <code>f(x1, ..., xN)</code>. </td></tr>
<tr>
<td align="left"><code>head(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Returns the first element of a sequence. </td></tr>
<tr>
<td align="left"><code>tail(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Returns all the elements except the first one. Analogous to <code>pop_front</code>. </td></tr>
<tr>
<td align="left"><code>is_empty(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Returns whether a sequence is empty as an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>at(index, sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Returns the n-th element of a sequence. The index must be an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>last(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Returns the last element of a sequence. </td></tr>
<tr>
<td align="left"><code>drop(number, sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Drops the n first elements from a sequence and returns the rest. <code>n</code> must be an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>drop_{while,until}(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_iterable.html" title="The Iterable concept represents data structures supporting external iteration. ">Iterable</a> </td><td align="left">Drops elements from a sequence while/until a predicate is satisfied. The predicate must return an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>flatten(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> </td><td align="left">Flatten a sequence of sequences, a bit like <code>std::tuple_cat</code>. </td></tr>
<tr>
<td align="left"><code>prepend(value, sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="left">Prepend an element to a sequence. </td></tr>
<tr>
<td align="left"><code>append(sequence, value)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="left">Append an element to a sequence. </td></tr>
<tr>
<td align="left"><code>concat(sequence1, sequence2)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="left">Concatenate two sequences. </td></tr>
<tr>
<td align="left"><code>filter(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="left">Remove all the elements that do not satisfy a predicate. The predicate must return an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>remove_if(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="left">Remove all the elements that satisfy a predicate. The predicate must return an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. </td></tr>
<tr>
<td align="left"><code>remove(sequence, value)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_monad_plus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> </td><td align="left">Remove all the elements that are equal to a given value. </td></tr>
<tr>
<td align="left"><code>{any,none,all}_of(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="left">Returns whether any/none/all of the elements of the sequence satisfy some predicate. </td></tr>
<tr>
<td align="left"><code>{any,none,all}(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="left">Returns whether any/non/all of the elements of a sequence are true-valued. </td></tr>
<tr>
<td align="left"><code>elem(sequence, value)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="left">Returns whether an object is in a sequence. </td></tr>
<tr>
<td align="left"><code>find_if(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="left">Find the first element of a sequence satisfying the predicate and return <code>just</code> it, or return <code>nothing</code>. See <a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a>. </td></tr>
<tr>
<td align="left"><code>find(sequence, value)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_searchable.html" title="The Searchable concept represents structures that can be searched. ">Searchable</a> </td><td align="left">Find the first element of a sequence which compares equal to some value and return <code>just</code> it, or return nothing. See <a class="el" href="structboost_1_1hana_1_1_maybe.html" title="Represents an optional value. ">Maybe</a>. </td></tr>
<tr>
<td align="left"><code>group(sequence[, predicate])</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Group adjacent elements of a sequence which all satisfy (or all do not satisfy) some predicate. The predicate defaults to equality, in which case the elements must be <a class="el" href="structboost_1_1hana_1_1_comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a>. </td></tr>
<tr>
<td align="left"><code>init(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Returns all the elements of a sequence, except the last one. Analogous to <code>pop_back</code>. </td></tr>
<tr>
<td align="left"><code>partition(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Partition a sequence into a pair of elements that satisfy some predicate, and elements that do not satisfy it. </td></tr>
<tr>
<td align="left"><code>remove_at(index, sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Remove the element at the given index. The index must be an <code>integral_constant</code>. </td></tr>
<tr>
<td align="left"><code>reverse(sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Reverse the order of the elements in a sequence. </td></tr>
<tr>
<td align="left"><code>slice(sequence, from, to)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Returns the elements of a sequence at indices contained in <code>[from, to)</code>. </td></tr>
<tr>
<td align="left"><code>subsequence(sequence, indices)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Returns the elements of a sequence at the <code>indices</code> in the given sequence. </td></tr>
<tr>
<td align="left"><code>sort(sequence[, predicate])</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Sort (stably) the elements of a sequence, optionally according to a predicate. The elements must be <a class="el" href="structboost_1_1hana_1_1_orderable.html" title="The Orderable concept represents totally ordered data types. ">Orderable</a> if no predicate is provided. </td></tr>
<tr>
<td align="left"><code>take(number, sequence)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Take the first n elements of a sequence. n must be an <code>integral_constant</code>. </td></tr>
<tr>
<td align="left"><code>take_{while,until}(sequence, predicate)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Take elements of a sequence while/until some predicate is satisfied, and return that. </td></tr>
<tr>
<td align="left"><code>zip(sequence1, ..., sequenceN)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Zip <code>N</code> sequences into a sequence of tuples. </td></tr>
<tr>
<td align="left"><code>zip.with(f, sequence1, ..., sequenceN)</code> </td><td align="left"><a class="el" href="structboost_1_1hana_1_1_sequence.html" title="The Sequence concept represents generic index-based sequences. ">Sequence</a> </td><td align="left">Zip <code>N</code> sequences with a <code>N</code>-ary function. </td></tr>
</table>
<h1><a class="anchor" id="tutorial-create"></a>
Creating sequences</h1>
<hr/>
<p> Like we saw in the quick start, a tuple can be created with <code>make_tuple</code>. In general, sequences in Hana may be created with the <code>make</code> function:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> xs = make&lt;Tuple&gt;(1, 2.2, <span class="charliteral">&#39;a&#39;</span>, std::string{<span class="stringliteral">&quot;bcde&quot;</span>});</div>
</div><!-- fragment --><p> Actually, <code>make_tuple</code> is just a shortcut for <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> so you don't have to type <code>boost::hana::make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">boost::hana::Tuple</a>&gt;</code> when you are out of Hana's namespace. Simply put, <code>make&lt;...&gt;</code> is is used all around the library to create different types of objects, thus generalizing the <code>std::make_xxx</code> family of functions. For example, one can create a <a class="el" href="structboost_1_1hana_1_1_range.html" title="Compile-time half-open interval of Constants. ">Range</a> of compile-time integers with <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_range.html" title="Compile-time half-open interval of Constants. ">Range</a>&gt;</code>:</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> r = make&lt;Range&gt;(int_&lt;3&gt;, int_&lt;10&gt;);</div>
<div class="line">static_assert(r == make_range(int_&lt;3&gt;, int_&lt;10&gt;), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><code>int_&lt;...&gt;</code> is not a type! It is a <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Variable_templates">C++14 variable template</a> yielding what Hana calls an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>.</dd></dl>
<p>For convenience, whenever a component of Hana provides a <code>make&lt;XXX&gt;</code> function, it also provides the <code>make_xxx</code> shortcut to reduce typing. Also, an interesting point that can be raised in this example is the fact that <code>r</code> is <code>constexpr</code>. In general, whenever a Hana sequence is initialized only with constant expressions (which is the case for <code>int_&lt;...&gt;</code>), that sequence may be marked as <code>constexpr</code>.</p>
<h1><a class="anchor" id="tutorial-assert"></a>
Assertions</h1>
<hr/>
<p> In the rest of this tutorial, you will come across code snippets in which different kinds of assertions like <code>BOOST_HANA_RUNTIME_CHECK</code> and <code>BOOST_HANA_CONSTANT_CHECK</code> are used. Like any sensible <code>assert</code> macro, they basically check that the condition they are given is satisfied. However, in the context of heterogeneous programming, some informations are known at compile-time, while others are known only at runtime. The exact type of assertion that's used in a context tells you whether the condition that's asserted upon can be known at compile-time or if it must be computed at runtime, which is very important to be aware of. Here are the different kinds of assertions used in the tutorial, with a small description of their particularities. For more details, you should check the <a class="el" href="group__group-assertions.html">reference on assertions</a>.</p>
<table class="doxtable">
<tr>
<th align="left">assertion </th><th align="left">description  </th></tr>
<tr>
<td align="left"><code>BOOST_HANA_RUNTIME_CHECK</code> </td><td align="left">Assertion on a condition that is not known until runtime. This assertion provides the weakest form of guarantee. </td></tr>
<tr>
<td align="left"><code>BOOST_HANA_CONSTEXPR_CHECK</code> </td><td align="left">Assertion on a condition that would be <code>constexpr</code> if lambdas were allowed inside constant expressions. In other words, it's not a <code>static_assert</code>, but only because lambdas are sometimes used inside the implementation and hence the result can't be <code>constexpr</code>. </td></tr>
<tr>
<td align="left"><code>BOOST_HANA_CONSTANT_CHECK</code> </td><td align="left">Assertion on a compile-time <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>. Basically, this means that the expression is in fact an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a> whose truth value is known at compile-time regardless of whether the value of the expression itself is known at compile-time, because that truth value is encoded in the type of the expression. This assertion provides the strongest form of guarantee. </td></tr>
</table>
<blockquote class="doxtable">
<p>Why don't we simply use <code>assert</code> and <code>static_assert</code>? That's because of language limitations documented in the section on <a class="el" href="index.html#tutorial-constexpr">constexpr's limitations</a>. </p>
</blockquote>
<h1><a class="anchor" id="tutorial-sem"></a>
Algorithm semantics</h1>
<hr/>
<p> By default, all the sequences in Hana hold their elements by value and hence they own them. For example, when creating a tuple, the tuple will make copies of the elements it is initialized with:</p>
<div class="fragment"><div class="line">std::string hello{<span class="stringliteral">&quot;Hello&quot;</span>};</div>
<div class="line">std::string world{<span class="stringliteral">&quot;world&quot;</span>};</div>
<div class="line"><span class="comment">// copies hello and world</span></div>
<div class="line">_tuple&lt;std::string, std::string&gt; xs{hello, world};</div>
</div><!-- fragment --><p> When given the chance, the tuple will move the values in:</p>
<div class="fragment"><div class="line">std::string hello{<span class="stringliteral">&quot;Hello&quot;</span>};</div>
<div class="line">std::string world{<span class="stringliteral">&quot;world&quot;</span>};</div>
<div class="line"><span class="comment">// moves hello and world</span></div>
<div class="line">_tuple&lt;std::string, std::string&gt; xs{std::move(hello), std::move(world)};</div>
</div><!-- fragment --><p> Algorithms in Hana always return a new sequence containing the result. This allows one to easily chain algorithms by simply using the result of the first as the input of the second. For example, to apply a function to every element of a tuple and then reverse the result, one simply has to connect the <code>reverse</code> and <code>transform</code> algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> to_str = [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; x) {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> xs = make_tuple(1, 2.2, <span class="charliteral">&#39;a&#39;</span>, <span class="stringliteral">&quot;bcde&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    reverse(transform(xs, to_str)) == make_tuple(<span class="stringliteral">&quot;bcde&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;2.2&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><p> This is different from the algorithms of the standard library, where one has to provide iterators to the underlying sequence. Iterator based designs have their own merits like low coupling and performance, but they also have drawbacks like reducing the composability of algorithms. In the context of heterogeneous sequences, iterators are also less useful. For example, incrementing an iterator would have to return a new iterator with a different type, because the type of the new object it is pointing to in the sequence might be different. To deal with complexity, Hana uses different abstractions that are composable and happen to be efficient given the heterogeneous setting.</p>
<p>Algorithms in Hana are not lazy. When an algorithm is called, it does its job and returns a new sequence containing the result, end of the story. For example, calling the <code>permutations</code> algorithm on a large sequence is a stupid idea, because Hana will actually compute all the permutations:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> perms = permutations(make_tuple(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));</div>
<div class="line"><span class="comment">// perms has 3 628 800 elements, and your compiler just crashed</span></div>
</div><!-- fragment --><p>To contrast, algorithms in Boost.Fusion return views which hold the original sequence by reference and apply the algorithm on demand, as the elements of the sequence are accessed. This leads to subtle lifetime issues, like having a view that refers to a sequence that was destroyed. Hana's design assumes that most of the time, we want to access all or almost all the elements in a sequence anyway, and hence performance is not a big argument in favor of laziness.</p>
<p>One might think that returning full sequences that own their elements from an algorithm would lead to tons of undesirable copies. For example, when using <code>reverse</code> and <code>transform</code>, one could think that an intermediate copy is made after the call to <code>transform</code>:</p>
<div class="fragment"><div class="line">reverse(</div>
<div class="line">    transform(xs, to_str) <span class="comment">// &lt;-- copy into reverse(...) here?</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> To make sure this does not happen, Hana uses perfect forwarding and move semantics heavily so it can provide an almost optimal runtime performance. So instead of doing a copy, a move occurs between <code>reverse</code> and <code>transform</code>:</p>
<div class="fragment"><div class="line">reverse(</div>
<div class="line">    transform(xs, to_str) <span class="comment">// &lt;-- nah, move from the temporary!</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Ultimately, the goal is that code written using Hana should be equivalent to clever hand-written code, except it should be enjoyable to write. Performance considerations are explained in depth in their own <a class="el" href="index.html#tutorial-perf">section</a>.</p>
<h1><a class="anchor" id="tutorial-amphi"></a>
Amphibian algorithms</h1>
<hr/>
<p> Like we saw in the quick start, some functions are able to return something that can be used in a constant expression even when they are called on a non-<code>constexpr</code> object. Let's refresh our memory a bit:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person { std::string name; };</div>
<div class="line"><span class="keyword">struct </span>Car    { std::string name; };</div>
<div class="line"><span class="keyword">struct </span>City   { std::string name; };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> stuff = make_tuple(Person{<span class="stringliteral">&quot;Louis&quot;</span>}, Car{<span class="stringliteral">&quot;Toyota&quot;</span>}, City{<span class="stringliteral">&quot;Quebec&quot;</span>});</div>
<div class="line"><span class="comment">//   ^^^^^ not constexpr</span></div>
<div class="line">static_assert(length(stuff) == 3u, <span class="stringliteral">&quot;&quot;</span>); <span class="comment">// &lt;--- used in a constant expression</span></div>
</div><!-- fragment --><p> Obviously, <code>stuff</code> can't be made <code>constexpr</code>, since it contains <code>std::string</code>s. Still, even though it is not called on a constant expression, <code>length</code> returns something that can be used inside one. If you think of it, the size of the tuple is known at compile-time regardless of its content, and hence it only makes sense that Hana does not throw away this information. If that seems surprising, think about <code>std::tuple</code>:</p>
<div class="fragment"><div class="line">std::tuple&lt;int, char, std::string&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, std::string{<span class="stringliteral">&quot;345&quot;</span>}};</div>
<div class="line">static_assert(std::tuple_size&lt;decltype(xs)&gt;::value == 3u, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Since the size of the tuple is encoded in it's type, it's always available at compile-time regardless of whether the tuple is <code>constexpr</code> or not. In Hana, this is implemented by having <code>length</code> return what we call an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. Since an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a> is convertible to the integral value it represents at compile-time, it can be used in a constant expression. There are subtleties that could be highlighted, but this is left to the more hardcore <a class="el" href="index.html#tutorial-constexpr">section</a> on the limitations of <code>constexpr</code>. <code>length</code> is not the only function that returns an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>; for example, <code>is_empty</code> does that too:</p>
<div class="fragment"><div class="line">static_assert(!is_empty(stuff), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> More generally, any algorithm that queries something that can be known at compile-time will be able of returning such an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>. To illustrate, let's take a look at the <code>all</code> algorithm, which is analogous to <code>std::all_of</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> result = all_of(stuff, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x.name == <span class="stringliteral">&quot;Louis&quot;</span>;</div>
<div class="line">});</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(!result);</div>
</div><!-- fragment --><p> Given a sequence and a predicate, <code>all</code> returns whether the predicate is satisfied by all the elements of the sequence. In this example, the result can't be known at compile-time, because our predicate returns a <code>bool</code> that's the result of comparing two <code>std::string</code>s. Since <code>std::string</code>s can't be compared at compile-time, our predicate must operate at runtime, and the overall result of the algorithm can then only be known at runtime too. However, let's say we used <code>all</code> with the following predicate instead:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = all_of(stuff, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::is_same&lt;</div>
<div class="line">        std::remove_reference_t&lt;decltype(x.name)&gt;,</div>
<div class="line">        std::string</div>
<div class="line">    &gt;{};</div>
<div class="line">});</div>
<div class="line">static_assert(result, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For this to work, the external adapters for <code>std::integral_constant</code> contained in <code><a class="el" href="ext_2std_2integral__constant_8hpp.html" title="Defines boost::hana::ext::std::IntegralConstant. ">boost/hana/ext/std/integral_constant.hpp</a></code> have to be included.</dd></dl>
<p>First, since the predicate is only querying information about the type of the <code>.name</code> member of an element of the tuple, it is clear that its result can be known at compile-time. Since the number of elements in the tuple is also known at compile-time, the overall result of the algorithm can, in theory, be known at compile-time. More precisely, what happens is that the predicate returns a default constructed <code>std::is_same&lt;...&gt;</code>, which inherits from <code>std::integral_constant</code>. Hana recognizes these objects, and <code>all</code> is written in such a way that it preserves the fact that the predicate's result is known at compile-time. In the end, <code>all</code> returns an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a> holding the result of the algorithm, and we use the compiler's type deduction in a clever way to make it look easy. Hence, it would be equivalent to write (but then you would need to already know the result of the algorithm!):</p>
<div class="fragment"><div class="line">_integral_constant&lt;bool, true&gt; result = all_of(stuff, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::is_same&lt;</div>
<div class="line">        std::remove_reference_t&lt;decltype(x.name)&gt;,</div>
<div class="line">        std::string</div>
<div class="line">    &gt;{};</div>
<div class="line">});</div>
<div class="line">static_assert(result, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> We just saw how some algorithms are able to return <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a></code>s when their inputs satisfy some constraints with respect to <code>compile-time</code>ness. However, other algorithms are more restrictive and they <em>require</em> their inputs to satisfy some constraints regarding <code>compile-time</code>ness, without which they are not able to operate at all. An example of this is <code>filter</code>, which takes a sequence and a predicate, and returns a new sequence containing only those elements for which the predicate is satisfied. <code>filter</code> requires the predicate to return an <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a> (actually, a <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> holding a <a class="el" href="structboost_1_1hana_1_1_logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>). While this requirement may seem stringent, it really makes sense if you think about it. Indeed, since we're removing some elements from the tuple, the type of the object that's going to be returned by <code>filter</code> depends on the result of the predicate. Hence, the result of the predicate has to be known by the compiler to fix the type of the returned sequence. For example, consider what happens when we try to filter our sequence as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = filter(stuff, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x.name == <span class="stringliteral">&quot;Louis&quot;</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p>Clearly, we know that the predicate will only return true on the first element, and hence the result <em>should be</em> a <code>_tuple&lt;Person&gt;</code>. However, the compiler has no way of knowing it since the predicate's result is the result of a runtime computation, which happens long after the compiler has finished its job. However, we could filter our sequence with any predicate whose result is available at compile-time:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = filter(stuff, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> std::is_same&lt;decltype(x), Car&gt;{};</div>
<div class="line">});</div>
</div><!-- fragment --><p> Since the predicate returns a <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a>, the compiler is able to figure out the return type of the algorithm. Other algorithms like <code>partition</code> and <code>sort</code> work similarly; special requirements are always documented by the functions they apply to. While this constitutes a fairly complete explanation of the interaction between runtime and compile-time inside algorithms, a deeper insight can be gained by reading the <a class="el" href="index.html#tutorial-constexpr">section</a> on the limitations of <code>constexpr</code> and the reference for <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> and <a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a>.</p>
<h1><a class="anchor" id="tutorial-type"></a>
Type computations</h1>
<hr/>
<p> At this point, if you are interested in doing Boost.MPL-like computations on types, you might be wondering how is Hana going to help you. Do not despair. Hana provides a way to perform type-level computations with a great deal of expressiveness by representing types as values. This is a completely new way of metaprogramming, and you should try to set your MPL habits aside for a bit if you want to become proficient with Hana. Basically, Hana provides a way of representing a type <code>T</code> as an object, and it also provides a way of applying type transformations to those objects as-if they were functions, by wrapping them properly:</p>
<div class="fragment"><div class="line"><span class="comment">// We &quot;lift&quot; the `int` type to a value, and the `std::add_pointer` metafunction</span></div>
<div class="line"><span class="comment">// to a regular function. Then, we can call that metafunction with a regular</span></div>
<div class="line"><span class="comment">// function call syntax.</span></div>
<div class="line">constexpr <span class="keyword">auto</span> t = type&lt;int&gt;;</div>
<div class="line">constexpr <span class="keyword">auto</span> add_pointer = metafunction&lt;std::add_pointer&gt;;</div>
<div class="line">static_assert(add_pointer(t) == type&lt;int*&gt;, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The <code>type&lt;int&gt;</code> expression is <em>not</em> a type! It is an object, more precisely a <a href="http://en.wikipedia.org/wiki/C%2B%2B14#Variable_templates">variable template</a> defined roughly as <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">constexpr the-type-of-the-<span class="keywordtype">object</span> type{};</div>
</div><!-- fragment --></dd></dl>
<p>Now, since <code>type&lt;...&gt;</code> is just an object, we can store it in a heterogeneous sequence like a tuple. This also means that all the algorithms that apply to usual heterogeneous sequences are available to us, which is nice:</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> types = make&lt;Tuple&gt;(type&lt;int&gt;, type&lt;char const&gt;, type&lt;void&gt;);</div>
<div class="line">static_assert(</div>
<div class="line">    transform(types, metafunction&lt;std::add_pointer&gt;) ==</div>
<div class="line">    make&lt;Tuple&gt;(type&lt;int*&gt;, type&lt;char const*&gt;, type&lt;void*&gt;)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> Also, since typing <code>type&lt;...&gt;</code> can be annoying at the end of the day, Hana provides a variable template called <code>tuple_t</code>, which creates a tuple of <code>type&lt;...&gt;</code>s:</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> types = tuple_t&lt;int, char const, void&gt;;</div>
<div class="line">static_assert(types == make&lt;Tuple&gt;(type&lt;int&gt;, type&lt;char const&gt;, type&lt;void&gt;), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">static_assert(</div>
<div class="line">    transform(types, metafunction&lt;std::add_pointer&gt;) ==</div>
<div class="line">    tuple_t&lt;int*, char const*, void*&gt;</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> I won't say much more about <code>type</code> and <code>metafunction</code> (see the <a class="el" href="structboost_1_1hana_1_1_type.html">reference</a>), but the last essential thing to know is that <code>decltype(type&lt;T&gt;)</code> is a MPL nullary metafunction. In other words, <code>decltype(type&lt;T&gt;)::type</code> is an alias to <code>T</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> T = decltype(t)::type;</div>
<div class="line">static_assert(std::is_same&lt;T, int&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> This way, you can recover the result of a type computation by unwrapping it with <code>decltype(...)::type</code>. Hence, doing type-level metaprogramming with Hana is usually a three step process:</p><ol type="1">
<li>Wrap the types with <code>type&lt;...&gt;</code> so they become values</li>
<li>Apply whatever type transformation <code>F</code> by using <code>metafunction&lt;F&gt;</code></li>
<li>Unwrap the result with <code>decltype(...)::type</code></li>
</ol>
<p>At this point, you must be thinking this is incredibly cumbersome. Why on earth would you want to write</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    decltype(metafunction&lt;std::add_pointer&gt;(type&lt;int&gt;))::type,</div>
<div class="line">    <span class="keywordtype">int</span>*</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> instead of simply writing</p>
<div class="fragment"><div class="line">static_assert(std::is_same&lt;</div>
<div class="line">    std::add_pointer&lt;int&gt;::type,</div>
<div class="line">    <span class="keywordtype">int</span>*</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> The answer is that of course you don't! For simple type computations such as this one, where you know the type transformation and the type itself, just use the most straightforward way of doing it. However, for more complex type computations, the syntactic noise of this three step process becomes negligible in light of the expressiveness gain of working with values instead of types inside that computation. Indeed, since we're working inside real functions instead of clunky structs, we can use variables, lambdas and a reasonable syntax. It also means that we don't need <code>typename</code> all around the place, which is nice (but can be avoided in MPL world with aliases). But this syntactic unification is not only some sugar for our eyes; it also means that some of our "metafunctions" will actually also work on normal values. Hence, any piece of generic enough code will work with both types and values out-of-the-box, without any extra work on our side. With previous approaches to type-level static metaprogramming, we had to reimplement type sequences and basically everything else from the ground up. For example, consider the simple problem of applying a transformation to each element in a sequence of sequences. For some metafunction <code>f</code> and sequence</p>
<div class="fragment"><div class="line">[</div>
<div class="line">    [x1, x2, ..., xN],</div>
<div class="line">    [y1, y2, ..., yM],</div>
<div class="line">    ...</div>
<div class="line">    [z1, z2, ..., zK]</div>
<div class="line">]</div>
</div><!-- fragment --><p>we want to produce a sequence</p>
<div class="fragment"><div class="line">[</div>
<div class="line">    [f&lt;x1&gt;::type, f&lt;x2&gt;::type, ..., f&lt;xN&gt;::type],</div>
<div class="line">    [f&lt;y1&gt;::type, f&lt;y2&gt;::type, ..., f&lt;yM&gt;::type],</div>
<div class="line">    ...</div>
<div class="line">    [f&lt;z1&gt;::type, f&lt;z2&gt;::type, ..., f&lt;zK&gt;::type]</div>
<div class="line">]</div>
</div><!-- fragment --><p>With Hana, this is very straightforward, and in fact the resulting algorithm will even work when given a regular function and values instead of a metafunction and types:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> apply_to_all = [](<span class="keyword">auto</span> sequences, <span class="keyword">auto</span> f) {</div>
<div class="line">    <span class="keywordflow">return</span> transform(sequences, [=](<span class="keyword">auto</span> sequence) {</div>
<div class="line">        <span class="keywordflow">return</span> transform(sequence, f);</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">constexpr <span class="keyword">auto</span> types = make&lt;Tuple&gt;(</div>
<div class="line">    tuple_t&lt;int, char&gt;,</div>
<div class="line">    tuple_t&lt;void, std::string, double&gt;</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">    apply_to_all(types, metafunction&lt;std::add_pointer&gt;) ==</div>
<div class="line">    make&lt;Tuple&gt;(</div>
<div class="line">        tuple_t&lt;int*, char*&gt;,</div>
<div class="line">        tuple_t&lt;void*, std::string*, double*&gt;</div>
<div class="line">    )</div>
<div class="line">);</div>
</div><!-- fragment --><p> However, expressing the same algorithm using Boost.MPL requires using lambda expressions, which are much more limited than plain lambdas. It also requires being at class or global scope, which means that you can't create this algorithm on the fly (e.g. inside a function), and it will only work on types!</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Sequences, <span class="keyword">typename</span> F&gt;</div>
<div class="line"><span class="keyword">struct </span>apply_to_all</div>
<div class="line">    : mpl::transform&lt;</div>
<div class="line">        Sequences,</div>
<div class="line">        mpl::transform&lt;mpl::_1, F&gt;</div>
<div class="line">    &gt;</div>
<div class="line">{ };</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> types = mpl::vector&lt;</div>
<div class="line">    mpl::vector&lt;int, char&gt;,</div>
<div class="line">    mpl::vector&lt;void, std::string, double&gt;</div>
<div class="line">&gt;;</div>
<div class="line"></div>
<div class="line">static_assert(mpl::equal&lt;</div>
<div class="line">    apply_to_all&lt;types, mpl::quote1&lt;std::add_pointer&gt;&gt;::type,</div>
<div class="line">    mpl::vector&lt;</div>
<div class="line">        mpl::vector&lt;int*, char*&gt;,</div>
<div class="line">        mpl::vector&lt;void*, std::string*, double*&gt;</div>
<div class="line">    &gt;,</div>
<div class="line"></div>
<div class="line">    <span class="comment">// mpl::equal was seemingly not designed for deep comparisons, so we</span></div>
<div class="line">    <span class="comment">// need this tricky line for it to do what we want.</span></div>
<div class="line">    mpl::equal&lt;mpl::_1, mpl::_2, mpl::quote2&lt;std::is_same&gt;&gt;</div>
<div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>That's it for the introduction to type computations with Hana, but there are a couple of interesting examples scattered in the documentation if you want more. There's also a minimal reimplementation of the MPL using Hana under the hood in <code>example/misc/mini_mpl.cpp</code>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd><ul>
<li>Provide links to the scattered examples, and also to example/misc/mini_mpl. For some reason, I can't get Doxygen to generate a link.</li>
<li>Expand this section to explain the philosophy behind Hana's metaprogramming paradigm, i.e. that you only retrieve the types at the end and that you do not try to represent everything as a type.</li>
<li>Write a cheatsheet mapping common MPL/Fusion idioms to idiomatic Hana code. Maybe this should go in some Appendix?</li>
<li>Introduce the mini-MPL</li>
<li>Introduce the integration with <code>&lt;type_traits&gt;</code></li>
</ul>
</dd></dl>
<h1><a class="anchor" id="tutorial-perf"></a>
Performance considerations</h1>
<hr/>
<p> C++ programmers love performance, so here's a whole section dedicated to it. Since Hana lives on the frontier between runtime and compile-time computations, we are not only interested in runtime performance, but also compile-time performance. Since both topics are pretty much disjoint, we treat them separately below.</p>
<dl class="section note"><dt>Note</dt><dd>The benchmarks presented in this section are updated automatically when we push to the repository. If you notice results that do not withstand the claims made here, open a <a href="https://github.com/ldionne/hana/issues">GitHub issue</a>; it could be a performance regression.</dd></dl>
<h2><a class="anchor" id="tutorial-perf-compile"></a>
Compile-time performance</h2>
<p>C++ metaprogramming brings its share of awful things. One of the most annoying and well-known problem associated to it is interminable compilation times. Hana claims to be more compile-time efficient than its predecessors; this is a bold claim and we will now try to back it. Of course, Hana can't do miracles; metaprogramming is a byproduct of the C++ template system and the compiler is not meant to be used as an interpreter for some meta language. However, by using cutting edge and intensely benchmarked techniques, Hana is able to minimize the strain on the compiler.</p>
<p>Before we dive, let me make a quick note on the methodology used to measure compile-time performance in Hana. Previous metaprogramming libraries measured the compile-time complexity of their meta-algorithms and meta-sequences by looking at the number of instantiations the compiler had to perform. While easy to understand, this way of measuring the compile-time complexity actually does not give us a lot of information regarding the compilation time, which is what we're interested in minimizing at the end of the day. Basically, the reason for this is that template metaprogramming is such a twisted model of computation that it's very hard to find a standard way of measuring the performance of algorithms. Hence, instead of presenting meaningless complexity analyses, we prefer to benchmark everything on every supported compiler and to pick the best implementation on that compiler. Now, let's dive.</p>
<p>First, Hana minimizes its dependency on the preprocessor. In addition to yielding cleaner error messages in many cases, this reduces the overall parsing and preprocessing time for header files. Also, because Hana only supports cutting edge compilers, there are very few workarounds in the library, which results in a cleaner and smaller library. Finally, Hana minimizes reliance on any kind of external dependencies. In particular, it only uses other Boost libraries in a few specific cases, and it does not rely on the standard library for the largest part. There are several reasons (other than include times) for doing so; they are documented in the <a class="el" href="index.html#tutorial-rationales">rationales</a>.</p>
<p>Below is a chart showing the time required to include different libraries. The chart shows the time for including everything in the (non-external) public API of each library. For example, for Hana this means the <code>&lt;<a class="el" href="hana_8hpp.html" title="Includes all the library components except the adapters for external libraries. ">boost/hana.hpp</a>&gt;</code> header, which excludes the external adapters. For other libraries like Boost.Fusion, this means including all the public headers in the <code>boost/fusion/</code> directory, but not the adapters for external libraries like the MPL.</p>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.including.compile.json"> </div><p>In addition to reduced preprocessing times, Hana uses modern techniques to implement heterogeneous sequences and algorithms in the most compile-time efficient way possible. Before jumping to the compile-time performance of the algorithms, we will have a look at the compile-time cost of creating heterogeneous sequences. Indeed, since we will be presenting algorithms that work on sequences, we must be aware of the cost of creating the sequences themselves, since that will influence the benchmarks for the algorithms. The following chart presents the compile-time cost of creating sequences of <code>n</code> elements.</p>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.make.compile.json"> </div><dl class="section note"><dt>Note</dt><dd>You can zoom on the chart by selecting an area to zoom into.</dd></dl>
<p>The benchmark methodology is to always create the sequences in the most efficient way possible. For Hana, this simply means using the <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> function. However, for the MPL, this means creating a <code>mpl::vectorN</code> of size up to 20, and then using <code>mpl::push_back</code> to create larger vectors. We use a similar technique for Fusion sequences. The reason for doing so is that Fusion and MPL sequences have fixed size limits, and the techniques used here have been found to be the fastest way to create longer sequences.</p>
<p>As you can see, Hana's compile-time <em>complexity</em> is better than the alternatives. However, if you look closer at the curves, you will see that the MPL has lower compile-times for small numbers of elements. This is because including Hana's <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> takes more time than including <code>mpl::vector</code>, and you are witnessing that slowdown by a constant amount. The reason why including Hana's <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> is slower than including <code>mpl::vector</code> is that Hana's <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> includes all the algorithms it can be used with, while <code>mpl::vector</code> only includes the strict minimum. Considering you need to include most of them manually when using the MPL, this constant slowdown will be nonexistent in real code and Hana's approach just makes it less painful for the programmer.</p>
<p>You can also see that creating sequences has a non-negligible cost. Actually, this is really the most expensive part, as you will see in the following charts showing the compile-time performance of algorithms. When you look at the charts here and elsewhere in the library, keep in mind the cost of merely creating the sequences. Also note that only the most important algorithms will be presented here, but micro benchmarks for compile-time performance are scattered in the reference documentation. Also, the benchmarks we present compare several different libraries. However, since Hana and Fusion can work with values and not only types, comparing their algorithms with type-only libraries like MPL is not really fair. Indeed, Hana and Fusion algorithms are more powerful since they also allow runtime effects to be performed. However, the comparison between Fusion and Hana is fair, because both libraries are just as powerful (strictly speaking).</p>
<p>The first algorithm which is ubiquitous in metaprogramming is <code>transform</code>. It takes a sequence and a function, and returns a new sequence containing the result of applying the function to each element. The following chart presents the compile-time performance of applying <code>transform</code> to a sequence of <code>n</code> elements. The <code>x</code> axis represents the number of elements in the sequence, and the <code>y</code> axis represents the compilation time in seconds. Also note that we're using the <code>transform</code> equivalent in each library; we're not using the <code>transform</code> algorithm from Hana through the Boost.Fusion adapters, for example, which would likely be less efficient.</p>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.transform.compile.json"> </div><p>You probably also noticed how there are multiple slightly different curves for Fusion and Hana's <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>. Those curves measure slightly different usage patterns for the <code>transform</code> algorithm. First, we benchmark <code>transform</code> when applied to sequences that contain both homogeneous and heterogeneous elements. The reason is that sequences holding heterogeneous elements tend to be less compile-time efficient, because the compiler has to instantiate more different types. Second, we benchmark the algorithm both on a standard Hana <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> and on a <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code> created through <code>hana::tuple_t</code>, and mapping a Hana <code><a class="el" href="structboost_1_1hana_1_1_metafunction.html" title="A Metafunction is a function that takes Types as inputs and gives a Type as output. ">Metafunction</a></code> instead of a regular function. The reason is that it is possible to optimize some algorithms (like <code>transform</code>) when we know we're actually mapping a metafunction on a type sequence. Basically, we can do the whole algorithm at the type level behind the scenes, which is more efficient, but you still get the nice value-level interface.</p>
<dl class="section note"><dt>Note</dt><dd>The representation of <code>tuple_t</code> is not really optimized right now, so there is no difference between using it and not using it. You should still use <code>tuple_t</code> to create type-only <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>s, as some nice optimizations can be implemented.</dd></dl>
<p>The second important class of algorithms are folds. Folds can be used to implement many other algorithms like <code>count_if</code>, <code>minimum</code> and so on. Hence, a good compile-time performance for fold algorithms ensures a good compile-time performance for those derived algorithms, which is why we're only presenting folds here. Also note that all the non-monadic fold variants are somewhat equivalent in terms of compile-time, so we only present the left folds. The following chart presents the compile-time performance of applying <code>fold.left</code> to a sequence of <code>n</code> elements. The <code>x</code> axis represents the number of elements in the sequence, and the <code>y</code> axis represents the compilation time in seconds. The function used for folding is a dummy function that does nothing. In real code, you would likely fold with a nontrivial operation, so the curves would be worse than that. However, these are micro benchmarks and hence they only show the performance of the algorithm itself.</p>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.fold_left.compile.json"> </div><p>The third and last algorithm that we present here is the <code>find_if</code> algorithm. This algorithm is difficult to implement efficiently, because it requires stopping at the first element which satisfies the given predicate. For the same reason, modern techniques don't really help us here, so this algorithm constitutes a good test of the implementation quality of Hana disregarding the metaprogramming free lunch given to us by C++14.</p>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.find_if.compile.json"> </div><p>As you can see, Hana performs better than Fusion, and as well as MPL, yet Hana's <code>find_if</code> can be used with values too, unlike MPL's. This concludes the section on compile-time performance, but there are micro benchmarks of compile-time performance scattered around the documentation if you want to see the compile-time behavior of a particular algorithm.</p>
<h2><a class="anchor" id="tutorial-perf-runtime"></a>
Runtime performance</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>Write this section.</dd></dl>
<h1><a class="anchor" id="tutorial-constexpr"></a>
The limitations of constexpr</h1>
<hr/>
<p> In C++, the border between compile-time and runtime is hazy, a fact that is even more true with the introduction of <a href="http://en.wikipedia.org/wiki/C%2B%2B11#constexpr_.E2.80.93_Generalized_constant_expressions">generalized constant expressions</a> in C++11. However, being able to manipulate heterogeneous objects is all about understanding that border and then crossing it at one's will. The goal of this section is to set things straight with <code>constexpr</code>; to understand which problems it can solve and which ones it can't. Let's start off with a <a href="http://www.gotw.ca/gotw/index.htm">GOTW</a> style question: do you think the following code should compile, and why?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">constexpr T assert_positive(T i) {</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keywordtype">int</span> i = 2;</div>
<div class="line">    assert_positive(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The right answer is "no". The error given by Clang goes like</p>
<div class="fragment"><div class="line">error: static_assert expression is not an integral constant expression</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">                  ^~~~~</div>
</div><!-- fragment --><p>The problem is that when you are in a function (<code>constexpr</code> or otherwise), you can't use an argument as a constant expression, even if the argument turns out to be a constant expression when you call the function. If you are surprised, consider the following code; the function is not a template anymore, which doesn't change anything with respect to the <code>constexpr</code>-ness of the argument if you think about it. Yet, the answer is now obvious:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> assert_positive(<span class="keywordtype">int</span> i) {</div>
<div class="line">    static_assert(i &gt; 0, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keywordtype">int</span> i = 2;</div>
<div class="line">    assert_positive(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Actually, since the body of <code>assert_positive</code> is not dependent anymore, Clang does not even reach <code>main</code> before giving the same error as before. Now, this is not a big problem for static assertions because we have <a href="http://stackoverflow.com/a/8626450/627587">another way</a> of reporting errors inside <code>constexpr</code> functions. However, it also means that we can't use an argument as a non-type template parameter, since that requires a constant expression. In other words, we can't create types that are dependent on the <em>value</em> of an argument in C++, which is nothing new if you think about it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> i&gt;</div>
<div class="line"><span class="keyword">struct </span>foo { };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i) {</div>
<div class="line">    foo&lt;i&gt; x; <span class="comment">// obviously won&#39;t work</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In particular, this means that the return type of a function can't depend on the value of its arguments; it may only depend on their type, and <code>constexpr</code> can't change this fact. This is of utmost importance to us, because we're interested in manipulating heterogeneous objects and eventually returning them from functions. Some of these functions might want to return an object of type <code>T</code> in one case and an object of type <code>U</code> in the other; from our little analysis, we now know that these "cases" will have to depend on information encoded in the <em>types</em> of the arguments, not in their <em>values</em>.</p>
<h2><a class="anchor" id="tutorial-constexpr-constants"></a>
Constants</h2>
<p>To represent this fact, Hana defines the concept of a <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>, which is an object from which a constant expression may always be obtained, regardless of the <code>constexpr</code>-ness of the object. <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s provide a way to obtain that constant expression through the use of the <code>value</code> function. Specifically, for any <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> <code>c</code>, the following must be valid:</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> x = value&lt;decltype(c)&gt;();</div>
</div><!-- fragment --><p>This requirement that must be respected by <code><a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code>s expresses the minimal requirement that we're able to retrieve a constant expression from an object. There is no restriction on what the type of the constant expression might be, but it should be documented. Hana provides a model of this concept called an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a></code>; it encodes a compile-time value of an integral type, and you can think of it as a <code>std::integral_constant</code>. Before going on to the next section, you probably want to take a look at the <a class="el" href="structboost_1_1hana_1_1_integral_constant.html">reference documentation</a> for <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="Represents a compile-time value of an integral type. ">IntegralConstant</a></code>, which explains how to create these objects and what you can expect from them.</p>
<h2><a class="anchor" id="tutorial-constexpr-side_effects"></a>
Side effects</h2>
<dl class="section note"><dt>Note</dt><dd>You should be familiar with the <a class="el" href="structboost_1_1hana_1_1_constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> concept before reading this section. Also note that this section contains somewhat advanced material, and it can safely be skipped during a first read.</dd></dl>
<p>Let me ask a tricky question. Is the following code valid?</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) { <span class="keywordflow">return</span> x; }</div>
<div class="line"></div>
<div class="line">static_assert(value(identity(bool_&lt;true&gt;)), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p>The answer is "no", but the reason might not be obvious at first. Even more puzzling is that the following code is perfectly valid:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) { <span class="keywordflow">return</span> x; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> x = identity(bool_&lt;true&gt;);</div>
<div class="line">static_assert(value(x), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> To understand why the compiler can't possibly evaluate the first assertion at compile-time, notice that <code>identity</code> was not marked <code>constexpr</code> and consider the following alternative (but valid) definition for <code>identity</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">auto</span> identity(X x) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Good luck in evaluating this at compile-time!&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The signature of the function did not change; the function could even have been defined in a separate source file. However, it is now obvious that the compiler can't evaluate that expression at compile-time. On the other hand, when we write</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = identity(bool_&lt;true&gt;);</div>
<div class="line">static_assert(value(x), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><p> we're telling the compiler to perform those potential side effects during the dynamic initialization phase! Then, we use <code>value</code> to return the compile-time value associated to its argument. Also note that <code>value</code> takes a <code>const&amp;</code> to its argument; if it tried taking it by value, we would be reading from a non-<code>constexpr</code> variable to do the copying, and that could hide side-effects.</p>
<h1><a class="anchor" id="tutorial-hetero"></a>
Heterogeneity and generalized types</h1>
<hr/>
<p> The purpose of Hana is to manipulate heterogeneous objects. However, there's a fundamental question that we have not asked yet: does it even make sense to manipulate heterogeneous objects?</p>
<p>For the sake of the explanation, let me make the following claim: a function template that compiles with an argument of every possible type must have a trivial implementation, in the sense that it must do nothing with its argument except perhaps return it. Hence, for a function template to do something interesting, it must fail to compile for some set of arguments. While I won't try to prove that claim formally &ndash; it might be false in some corner cases &ndash;, think about it for a moment. Let's say I want to apply a function to each element of an heterogeneous sequence:</p>
<div class="fragment"><div class="line">for_each([x, y, z], f)</div>
</div><!-- fragment --><p>The first observation is that <code>f</code> must have a templated call operator because <code>x</code>, <code>y</code> and <code>z</code> have different types. The second observation is that without knowing anything specific about the types of <code>x</code>, <code>y</code> and <code>z</code>, it is impossible for <code>f</code> to do anything meaningful. For example, could it print its argument? Of course not, since it does not know whether <code>std::cout &lt;&lt; x</code> is well-formed! In order to do something meaningful, the function has to put constraints on its arguments; it has to define a domain which is more specific that the set of all types, and hence it can't be <em>fully</em> polymorphic, even if we do not have a way to express this in C++ (right now). So while we're manipulating types that are technically heterogeneous, they still conceptually need something in common, or it wouldn't be possible to do anything meaningful with them. We'll still say that we're manipulating heterogeneous objects, but always keep in mind that the objects we manipulate share something, and are hence homogeneous in <em>some way</em>.</p>
<p>Pushing this to the extreme, some type families represent exactly the same entity, except they must have a different C++ type because the language requires them to. For example, this is the case of <code>_tuple&lt;...&gt;</code>. In our context, we would like to see <code>_tuple&lt;int, int&gt;</code> and <code>_tuple&lt;int, long, float&gt;</code> as different representations for the same data structure (a "tuple"), but the C++ language requires us to give them different types. In Hana, we associate what we call a <em>generalized type</em> (we also say <em>data type</em> and sometimes <em>gtype</em>) to each type family. A generalized type is simply a tag (like in MPL or Fusion) which is associated to all the types in a family through the <code>datatype</code> metafunction. For <code>_tuple&lt;...&gt;</code>, this generalized type is <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>; other constructs in Hana also follow this convention of naming their generalized type with a capital letter.</p>
<p>Just like C++ templates are families of types that are parameterized by some other type, it makes sense to speak of parameterized generalized types. A parameterized <em>gtype</em> is simply a <em>gtype</em> which depends on other generalized types. You might have seen it coming, but this is actually the case for <code>_tuple</code>, whose <em>gtype</em> can be seen as depending on the <em>gtype</em> of the objects it contains. However, take good note that <b>parameterized generalized types in Hana only live at the documentation level</b>. While enforcing proper parametricity would make the library more mathematically correct, I fear it would also make it less usable given the lack of language support. Given a parametric <em>gtype</em> <code>F</code>, we use <code>F(T)</code> to denote the "application" of <code>F</code> to another <em>gtype</em> <code>T</code>. While this is analogous to "applying" a C++ template to a type, we purposefully do not use the <code>F&lt;T&gt;</code> notation because parametric gtypes are not necessarily templates in Hana and that would be more confusing than helpful.</p>
<p>As an example, <code>_tuple&lt;int, int&gt;</code> conceptually has a gtype of <code>Tuple(int)</code>, but its actual gtype (outside of the documentation) is just <code><a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a></code>. What about <code>_tuple&lt;int, long&gt;</code>? Well, <code>int</code> and <code>long</code> are embedded in the same mathematical universe, so we could say that it's a <code>Tuple(Number)</code>, where <code>Number</code> is some generalized type containing all the numeric types. What about <code>_tuple&lt;int, void&gt;</code>? First, that won't compile. But why would you create a sequence of objects that have nothing in common? What can you do with that?</p>
<p>These generalized types are useful for several purposes, for example creating a tuple with <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code> and documenting pseudo-signatures for the functions provided in this library. Another important role is to customize algorithms; see the section on <a class="el" href="index.html#tutorial-extending-tag_dispatching">tag-dispatching</a> for more information. Finally, you can also consult the reference of the <a class="el" href="structboost_1_1hana_1_1datatype.html">datatype</a> metafunction for details on how to specify the generalized type of a family of types.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>There is obviously a connection between generalized types and concepts. I think that generalized types are concepts whose models are unique up to a unique isomorphism. Still, it is necessary to distinguish between isomorphic models when we want to provide an implementation or create an object. If you see how it all fits together better than I do right now, let me know.</dd></dl>
<h1><a class="anchor" id="tutorial-ext"></a>
Integration with external libraries</h1>
<hr/>
<h2><a class="anchor" id="tutorial-ext-std"></a>
The standard library</h2>
<h2><a class="anchor" id="tutorial-ext-fusion"></a>
Boost.Fusion</h2>
<h2><a class="anchor" id="tutorial-ext-mpl"></a>
Boost.MPL</h2>
<h1><a class="anchor" id="tutorial-extending"></a>
Extending the library</h1>
<hr/>
<p> Because of its modular design, Hana can be extended in a ad-hoc manner very easily. Actually, all the functionality of the library is provided through this ad-hoc customization mechanism.</p>
<h2><a class="anchor" id="tutorial-extending-tag_dispatching"></a>
Tag dispatching</h2>
<p>Tag dispatching is a generic programming technique for picking the right implementation of a function depending on the type of the arguments passed to the function. The usual mechanism for overriding a function's behavior is overloading. Unfortunately, this mechanism is not always convenient when dealing with families of related types having different C++ types, or with objects of unspecified types as is often the case in Hana. For example, consider trying to overload a function for all Boost.Fusion vectors:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <span class="keyword">function</span>(boost::fusion::vector&lt;T...&gt; v) {</div>
<div class="line">    <span class="comment">// whatever</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>If you know Boost.Fusion, then you probably know that it won't work. This is because Boost.Fusion vectors are not necessarily specializations of the <code>boost::fusion::vector</code> template. Fusion vectors also exist in numbered forms, which are all of different types:</p>
<div class="fragment"><div class="line">boost::fusion::vector1&lt;T&gt;</div>
<div class="line">boost::fusion::vector2&lt;T, U&gt;</div>
<div class="line">boost::fusion::vector3&lt;T, U, V&gt;</div>
<div class="line">...</div>
</div><!-- fragment --><p>This is an implementation detail required by the lack of variadic templates in C++03 that leaks into the interface. This is unfortunate, but we need a way to work around it. To do so, we use an infrastructure with three distinct components:</p>
<ol type="1">
<li>A metafunction associating a single tag to every type in a family of related types. In Hana, we use the generalized type of an object, which is accessible through the <code>datatype</code> metafunction.</li>
<li>A function belonging to the public interface of the library, for which we'd like to be able to provide a customized implementation.</li>
<li>An implementation for the function, parameterized with the data type(s) of the argument(s) passed to the function.</li>
</ol>
<p>When the public interface function is called, it will use the metafunction on its argument(s) (or a subset thereof) to obtain their data type(s) and redirect to the implementation associated to those data type(s). For example, a basic setup for tag dispatching of a function that prints its argument to a stream would look like:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Datatype&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; <span class="comment">/*os*/</span>, X <span class="comment">/*x*/</span>) {</div>
<div class="line">        <span class="comment">/* possibly some default implementation */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keywordtype">void</span> print(std::ostream&amp; os, X x) {</div>
<div class="line">    <span class="keyword">using</span> Datatype = <span class="keyword">typename</span> <a class="code" href="structboost_1_1hana_1_1datatype.html">boost::hana::datatype&lt;X&gt;::type</a>;</div>
<div class="line">    <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">print_impl&lt;Datatype&gt;::apply</a>(os, x);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Then, if you want to customize the behavior of the <code>print</code> function for some user defined family of types, you only need to specialize the <code>print_impl</code> template for the tag representing the whole family of types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>print_impl&lt;UserDefinedDatatype&gt; {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(std::ostream&amp; <span class="comment">/*os*/</span>, X <span class="comment">/*x*/</span>) {</div>
<div class="line">        <span class="comment">/* a custom implementation for some data type */</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="tutorial-extending-creating_concepts"></a>
Creating new concepts</h2>
<h1><a class="anchor" id="tutorial-header_organization"></a>
Header organization</h1>
<hr/>
<p> The library is designed to be modular while keeping the number of headers that must be included to get basic functionality reasonably low. The structure of the library was also intentionally kept simple, because we all love simplicity.</p>
<ul>
<li><code><a class="el" href="hana_8hpp.html" title="Includes all the library components except the adapters for external libraries. ">boost/hana.hpp</a></code><br />
 This is the master header of the library. It includes the whole public interface of the library except adapters for external libraries, which must be included separately.</li>
<li><code>boost/hana/</code><br />
 This is the main directory of the library containing the definitions of concepts and data types. A file of the form <code>boost/hana/[XXX].hpp</code> contains the definition for the concept or data type named <code>XXX</code>.<ul>
<li><code>boost/hana/core/</code><br />
 This subdirectory contains the machinery for tag-dispatching and other related utilities like <code>make</code> and <code>to</code>.</li>
<li><code>boost/hana/fwd/</code><br />
 This subdirectory contains the forward declaration of every concept and data type in the library. Basically, <code>boost/hana/fwd/[XXX].hpp</code> is the forward declaration for the concept or data type named <code>XXX</code>. Also note that forward declarations for headers in <code>boost/hana/ext/</code> are not provided.</li>
<li><code>boost/hana/functional/</code><br />
 This subdirectory contains various function objects that are often useful, but that do not necessarily belong to a concept.</li>
<li><code>boost/hana/ext/</code><br />
 This directory contains adapters for external libraries. Only the strict minimum required to adapt the external components is included in these headers (e.g. a forward declaration). This means that the definition of the external component should still be included when one wants to use it. For example: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2tuple_8hpp.html">boost/hana/ext/std/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span> <span class="comment">// still required to create a tuple</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr std::tuple&lt;int, char, float&gt; xs{1, <span class="charliteral">&#39;2&#39;</span>, 3.0f};</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(head(xs) == 1);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><code>boost/hana/detail/</code><br />
 This directory contains utilities required internally. Nothing in <code>detail/</code> is guaranteed to be stable, so you should not use it.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="tutorial-using_the_reference"></a>
Using the reference</h1>
<hr/>
<p> You now have everything you need to start using the library. From here on, mastering the library is only a matter of understanding and knowing how to use the general purpose concepts and data types provided with it, which is best done by looking at the reference documentation. At some point, you will probably also want to create your own concepts and data types that fit your needs better; go ahead, the library was intended to be used that way.</p>
<p>The structure of the reference (available in the menu to the left) goes as follow:</p><ul>
<li><a class="el" href="group__group-core.html">Core</a><br />
 Documentation for the core module, which contains everything needed to create concepts, data types and related utilities. This is relevant if you need to extend the library, but otherwise you can probably ignore this.</li>
<li><a class="el" href="group__group-functional.html">Functional</a><br />
 General purpose function objects that are generally useful in a purely functional setting. These are currently not tied to any concept or data type.</li>
<li><a class="el" href="group__group-concepts.html">Concepts</a><br />
 Documentation for all the concepts provided with the library. Each concept:<ul>
<li>Documents laws that are internal to this concept</li>
<li>Documents the concept(s) it is derived from, if any. In the documentation, we usually call those base concepts <em>superclasses</em>. Sometimes, a concept is powerful enough to provide a model of its superclass, or at least the implementation for some of its methods. When this is the case, the concept will document which superclass methods it provides, and how it does so. Also, it is sometimes possible that the model for a superclass is unique, in which case it can be provided automatically. When this happens, it will be documented but you don't have to do anything special to get that model.</li>
<li>Documents which methods must be implemented absolutely in order to model that concept.</li>
</ul>
</li>
<li><a class="el" href="group__group-datatypes.html">Data types</a><br />
 Documentation for all the data types provided with the library. Each data type documents the concept(s) it models, and how it does so. It also documents the methods tied to that data type but not to any concept, for example <code>make&lt;<a class="el" href="structboost_1_1hana_1_1_tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">Tuple</a>&gt;</code>.</li>
<li><a class="el" href="group__group-ext.html">External adapters</a><br />
 Documentation for all the adapters for external libraries. Basically, we assign a data type to some objects in external libraries and we document them as if they were normal data types provided by Hana.</li>
<li><a class="el" href="group__group-config.html">Configuration options</a><br />
 Macros that can be used to tweak the global behavior of the library.</li>
<li><a class="el" href="group__group-assertions.html">Assertions</a><br />
 Macros to perform various types of assertions.</li>
<li><a class="el" href="group__group-details.html">Details</a><br />
 Implementation details. Don't go there.</li>
</ul>
<h2><a class="anchor" id="tutorial-using_the_reference-pseudo"></a>
Pseudo-code glossary</h2>
<p>In the documentation, a simplified implementation of the documented object is sometimes provided in pseudo-code. The reason is that the actual implementation is sometimes contrived because of unimportant details or language limitations. Here is an explanation of some terms that appear in the pseudo-code:</p>
<ul>
<li><p class="startli"><code>forwarded(x)</code><br />
 Means that the object is forwarded optimally. This means that if <code>x</code> is a parameter, it is <code>std::forward</code>ed, and if it is a captured variable, it is moved from whenever the enclosing lambda is an rvalue.</p>
<p class="startli">Also note that when <code>x</code> can be moved from, the statement <code>return forwarded(x);</code> in a function with <code>decltype(auto)</code> does not mean that an rvalue reference to <code>x</code> will be returned, which would create a dangling reference. Rather, it means that <code>x</code> is returned by value, the value being constructed with the <code>std::forward</code>ed <code>x</code>.</p>
</li>
<li><code>perfect-capture</code><br />
 This is used in lambdas to signify that the captured variables are initialized using perfect forwarding, as if <code>[x(forwarded(x))...]() { }</code> had been used.</li>
<li><code>decayed(T)</code><br />
 Represents a type <code>T</code> after decaying. This is basically equivalent to <code>std::decay_t&lt;T&gt;</code>.</li>
<li><code>tag-dispatched</code><br />
 This means that the documented method uses tag-dispatching, and hence the exact implementation depends on the model of the concept associated to the method.</li>
<li><code>unspecified-type</code><br />
 This is used to express the fact that the return-type of a function is unspecified, and hence you should not rely on it being anything special beyond what is documented. Normally, the concepts satisfied by the returned object will be specified, because otherwise that function wouldn't be very useful.</li>
</ul>
<hr/>
<p> This finishes the tutorial part of the documentation. I hope you enjoy using the library, and please leave feedback on GitHub so we can improve the library!</p>
<p>&ndash; Louis</p>
<h1><a class="anchor" id="tutorial-rationales"></a>
Rationales/FAQ</h1>
<hr/>
<p> This section documents the rationale for some design choices. It also serves as a FAQ for some (not so) frequently asked questions. If you think something should be added to this list, open a GitHub issue and we'll consider either improving the documentation or adding the question here.</p>
<ol type="1">
<li>Why restrict usage of Boost and the standard library? After all, isn't this a (proposed) Boost library? There are several reasons for doing so. First, Hana is a very fundamental library; we are basically reimplementing the core language and the standard library with support for heterogeneous types. When you go through the code, you quickly realize that you very rarely need other libraries, and that almost everything must be implemented from scratch. Also, since Hana is very fundamental, there is even more incentive for keeping the dependencies minimal, because those dependencies will be handed down to the users. Finally, one big reason for using Boost is that it is highly portable. As an exception to the rule, this library only targets very recent compilers. Hence, we can afford to depend on modern constructs and the portability brought by using most Boost libraries is just dead weight. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
