<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Hana: boost::hana::MonadPlus Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/data.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/modules/exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="https://cdn.rawgit.com/michael/github/fb54ae3856341ef4bd3acf877ccf24836fc079d9/github.js"></script>
<script type="text/javascript">
  window.onload = function() {
    // We parse the code snippets and italicize the words from the pseudo-code
    // glossary to make them stand out. We also link them to their respective
    // definition in the glossary.
    $(".fragment").children(".line").each(function(index, div) {
      div.innerHTML = div.innerHTML
        .replace(/perfect-.+(?=])/g, "perfect-capture".link("index.html#tutorial-glossary-perfect_capture").italics())
        .replace(/forwarded/g, "forwarded".link("index.html#tutorial-glossary-forwarded").italics())
        .replace(/tag-dispatched/g, "tag-dispatched".link("index.html#tutorial-glossary-tag_dispatched").italics())
        .replace(/unspecified-type/g, "unspecified-type".link("index.html#tutorial-glossary-unspecified_type").italics())
        .replace(/see-documentation/g, "see-documentation".italics());
    });
    var github = new Github({});
    var hana = github.getRepo('ldionne', 'hana');
    hana.getRef('heads/datasets', function(err, sha) {
      var repo = "https://cdn.rawgit.com/ldionne/hana/" + sha + "/release/clang-3.6.1/";
      $(".benchmark-chart").each(function(index, div) {
        var dataset = div.getAttribute("data-dataset");
        $.getJSON(repo + dataset, function(options) {
          Hana.initChart($(div), options);
        });
      });
    });
  };
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1MonadPlus.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="structboost_1_1hana_1_1MonadPlus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::MonadPlus Struct Reference<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a></code> concept represents Monads with a monoidal structure. </p>
<p>Intuitively, whereas a <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> can be seen as some kind of container or context, a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> can be seen as a container or a context that can be concatenated with other containers or contexts. There must also be an identity element for this combining operation. For example, a <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="Tag representing a general purpose index-based heterogeneous sequence with a fixed length...">Tuple</a></code> is a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, because tuples can be concatenated and the empty tuple would act as an identity for concatenation. How is this different from a <a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a> which is also a <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a>? The answer is that the monoidal structure on a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> must <em>not</em> depend of the contents of the structure; it must not require the contents to be a <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> in order to work.</p>
<p>While sequences are not the only possible model for <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, the method names used here refer to the <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> of sequences under concatenation. Several useful functions generalizing operations on sequences are included with this concept, like <code>append</code>, <code>prepend</code> and <code>filter</code>.</p>
<h2>Minimal complete definition </h2>
<p><code>concat</code> and <code>empty</code></p>
<h2>Laws </h2>
<p>First, a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> is required to have a monoidal structure. Hence, it is no surprise that for any <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, we require <code>M(T)</code> to be a valid monoid. However, we do not enforce that <code>M(T)</code> actually models the <a class="el" href="structboost_1_1hana_1_1Monoid.html" title="The Monoid concept represents data types with an associative binary operation that has an identity...">Monoid</a> concept provided by Hana. Further, for all objects <code>a, b, c</code> of data type <code>M(T)</code>, </p><div class="fragment"><div class="line"><span class="comment">// identity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;(), a) == a</div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(a, <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;()) == a</div>
<div class="line"></div>
<div class="line"><span class="comment">// associativity</span></div>
<div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(a, <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(b, c)) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(a, b), c)</div>
</div><!-- fragment --><p>Second, a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> is also required to obey the following laws, which represent the fact that <code>empty&lt;M(T)&gt;()</code> must be some kind of absorbing element for the <code>chain</code> operation. For all objects <code>a</code> of data type <code>M(T)</code> and functions \( f : T \to M(U) \), </p><div class="fragment"><div class="line">chain(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;(), f)         == empty&lt;M(U)&gt;()</div>
<div class="line">chain(a, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(T)&gt;())) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a>&lt;M(U)&gt;()</div>
</div><!-- fragment --><h2>Refined concepts </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1Functor.html" title="The Functor concept represents types that can be mapped over. ">Functor</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Applicative.html" title="The Applicative concept represents Functors with the ability to lift values and combine computations...">Applicative</a></code> and <code><a class="el" href="structboost_1_1hana_1_1Monad.html" title="The Monad concept represents Applicatives with the ability to flatten nested levels of structure...">Monad</a></code></p>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1Optional.html" title="Tag representing an optional value whose optional-ness is known at compile-time. ">Optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1Tuple.html" title="Tag representing a general purpose index-based heterogeneous sequence with a fixed length...">Tuple</a></code> </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a></td></tr>
<tr class="memdesc:a30a6926751dfcafbe2bb67738e2da3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two monadic structures together.  <a href="#a30a6926751dfcafbe2bb67738e2da3c4">More...</a><br /></td></tr>
<tr class="separator:a30a6926751dfcafbe2bb67738e2da3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ad3cf817440c20f200f91d4fa4e789"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a91ad3cf817440c20f200f91d4fa4e789"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a91ad3cf817440c20f200f91d4fa4e789">empty</a></td></tr>
<tr class="memdesc:a91ad3cf817440c20f200f91d4fa4e789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity of the monadic combination <code>concat</code>.  <a href="#a91ad3cf817440c20f200f91d4fa4e789">More...</a><br /></td></tr>
<tr class="separator:a91ad3cf817440c20f200f91d4fa4e789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e173a5524274624703353bb3ac4c129"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a3e173a5524274624703353bb3ac4c129">prepend</a></td></tr>
<tr class="memdesc:a3e173a5524274624703353bb3ac4c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to a monadic structure.  <a href="#a3e173a5524274624703353bb3ac4c129">More...</a><br /></td></tr>
<tr class="separator:a3e173a5524274624703353bb3ac4c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae469094a7fee3a0f7dfcc900da9b07b4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a></td></tr>
<tr class="memdesc:ae469094a7fee3a0f7dfcc900da9b07b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to a monadic structure.  <a href="#ae469094a7fee3a0f7dfcc900da9b07b4">More...</a><br /></td></tr>
<tr class="separator:ae469094a7fee3a0f7dfcc900da9b07b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929370eddd43bb1a4a11b00a7880eadb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a></td></tr>
<tr class="memdesc:a929370eddd43bb1a4a11b00a7880eadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a monadic structure using a custom predicate.  <a href="#a929370eddd43bb1a4a11b00a7880eadb">More...</a><br /></td></tr>
<tr class="separator:a929370eddd43bb1a4a11b00a7880eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cd26f8259bdd4306cd0907ef578b47"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a></td></tr>
<tr class="memdesc:a15cd26f8259bdd4306cd0907ef578b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a monadic structure with itself <code>n</code> times.  <a href="#a15cd26f8259bdd4306cd0907ef578b47">More...</a><br /></td></tr>
<tr class="separator:a15cd26f8259bdd4306cd0907ef578b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad993eca017378409ad0b3a2e6b6807ff"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#ad993eca017378409ad0b3a2e6b6807ff">remove_if</a></td></tr>
<tr class="memdesc:ad993eca017378409ad0b3a2e6b6807ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the elements of a monadic structure that satisfy some predicate.  <a href="#ad993eca017378409ad0b3a2e6b6807ff">More...</a><br /></td></tr>
<tr class="separator:ad993eca017378409ad0b3a2e6b6807ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2f3034ed81a7bfff513a5b5f82031"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a08e2f3034ed81a7bfff513a5b5f82031">remove</a></td></tr>
<tr class="memdesc:a08e2f3034ed81a7bfff513a5b5f82031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the elements of a monadic structure that are equal to some value.  <a href="#a08e2f3034ed81a7bfff513a5b5f82031">More...</a><br /></td></tr>
<tr class="separator:a08e2f3034ed81a7bfff513a5b5f82031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#acbf4797cf95bb19dfe33a16cf86fe3c9">repeat</a></td></tr>
<tr class="memdesc:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a monadic structure by combining a lifted value with itself <code>n</code> times.  <a href="#acbf4797cf95bb19dfe33a16cf86fe3c9">More...</a><br /></td></tr>
<tr class="separator:acbf4797cf95bb19dfe33a16cf86fe3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ba602a660bdb3bbeb43cc600de3008"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a85ba602a660bdb3bbeb43cc600de3008">prefix</a></td></tr>
<tr class="memdesc:a85ba602a660bdb3bbeb43cc600de3008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value before each element of a monadic structure.  <a href="#a85ba602a660bdb3bbeb43cc600de3008">More...</a><br /></td></tr>
<tr class="separator:a85ba602a660bdb3bbeb43cc600de3008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6622ade385d42bf03dd18f226cd080"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html#a9b6622ade385d42bf03dd18f226cd080">suffix</a></td></tr>
<tr class="memdesc:a9b6622ade385d42bf03dd18f226cd080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value after each element of a monadic structure.  <a href="#a9b6622ade385d42bf03dd18f226cd080">More...</a><br /></td></tr>
<tr class="separator:a9b6622ade385d42bf03dd18f226cd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="a30a6926751dfcafbe2bb67738e2da3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto concat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine two monadic structures together. </p>
<p>Given two monadic structures, <code>concat</code> combines them together and returns a new monadic structure. The exact definition of <code>concat</code> will depend on the exact model of <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> at hand, but for sequences it corresponds intuitively to simple concatenation.</p>
<p>Also note that combination is not required to be commutative. In other words, there is no requirement that </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, ys) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(ys, xs)</div>
</div><!-- fragment --><p> and indeed it does not hold in general.</p>
<h2>Signature </h2>
<p>Given <code>M</code> a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>, the signature is \( \mathrm{concat} : M(T) \times M(T) \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two monadic structures to combine together.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1hana_1_1literals.html">boost::hana::literals</a>;</div>
<div class="line"></div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(make_tuple(1, <span class="charliteral">&#39;2&#39;</span>),</div>
<div class="line">                     make_tuple(3.3, 4_c)) == make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91ad3cf817440c20f200f91d4fa4e789"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Identity of the monadic combination <code>concat</code>. </p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{empty}_M : \emptyset \to M(T) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The data type of the monadic structure to return. This must be a model of the <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(empty&lt;Tuple&gt;() == make_tuple());</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(empty&lt;Optional&gt;() == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3e173a5524274624703353bb3ac4c129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto prepend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Prepend an element to a monadic structure. </p>
<p>Given a monadic structure <code>xs</code> and an element <code>x</code>, <code>prepend</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the left) with <code>xs</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(xs, x) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(lift&lt;Xs&gt;(x), xs)</div>
</div><!-- fragment --><p>For sequences, this has the intuitive behavior of simply prepending an element to the beginning of the sequence, hence the name.</p>
<blockquote class="doxtable">
<h4>Rationale for not calling this <code>push_front</code></h4>
<p>While <code>push_front</code> is the de-facto name used in the standard library, it also strongly suggests mutation of the underlying sequence, which is not the case here. The author also finds that <code>push_front</code> suggests too strongly the sole interpretation of putting an element to the front of a sequence, whereas <code>prepend</code> is slightly more nuanced and bears its name better for e.g. <code><a class="el" href="structboost_1_1hana_1_1Optional.html" title="Tag representing an optional value whose optional-ness is known at compile-time. ">Optional</a></code>. </p>
</blockquote>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{prepend} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the right of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the left of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(make_tuple(), 1) == make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a3e173a5524274624703353bb3ac4c129">prepend</a>(make_tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3), 1) == make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae469094a7fee3a0f7dfcc900da9b07b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto append</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Append an element to a monadic structure. </p>
<p>Given an element <code>x</code> of data typeÂ <code>X</code> and a monadic structure <code>xs</code> containing objects of data type <code>X</code>, <code>append</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the right) with <code>xs</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(xs, x) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, lift&lt;Xs&gt;(x))</div>
</div><!-- fragment --><p>For sequences, this has the intuitive behavior of simply appending an element to the end of the sequence, hence the name.</p>
<blockquote class="doxtable">
<h4>Rationale for not calling this <code>push_back</code></h4>
<p>See the rationale for using <code>prepend</code> instead of <code>push_front</code>. </p>
</blockquote>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{append} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the left of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the right of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(make_tuple(), 1) == make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ae469094a7fee3a0f7dfcc900da9b07b4">append</a>(make_tuple(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a929370eddd43bb1a4a11b00a7880eadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; pred) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Filter a monadic structure using a custom predicate. </p>
<p>Given a monadic structure and a predicate, <code>filter</code> returns a new monadic structure containing only those elements that satisfy the predicate. This is a generalization of the usual <code>filter</code> function for sequences; it works for any <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a>. Intuitively, <code>filter</code> is somewhat equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(xs, pred) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> pred(x) ? lift&lt;Xs&gt;(x) : empty&lt;Xs&gt;();</div>
<div class="line">})</div>
</div><!-- fragment --><p> In other words, we basically turn a monadic structure containing <code>[x1, ..., xn]</code> into a monadic structure containing </p><div class="fragment"><div class="line">[</div>
<div class="line">    pred(x1) ? [x1] : [],</div>
<div class="line">    pred(x2) ? [x2] : [],</div>
<div class="line">    ...</div>
<div class="line">    pred(xn) ? [xn] : []</div>
<div class="line">]</div>
</div><!-- fragment --><p> and we then <code>flatten</code> that.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code> and a <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code>, the signature is \( \mathrm{filter} : M(T) \times (T \to \mathrm{Bool}) \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The monadic structure to filter.</td></tr>
    <tr><td class="paramname">pred</td><td>A function called as <code>pred(x)</code> for each element <code>x</code> in the monadic structure and returning a <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code> representing whether that element should be <b>kept</b> in the resulting structure. In the current version of the library, the predicate has to return a compile-time <code><a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(make_tuple(1, 2.0, 3, 4.0), trait&lt;std::is_integral&gt;) == make_tuple(1, 3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(just(3), trait&lt;std::is_integral&gt;) == just(3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(just(3.0), trait&lt;std::is_integral&gt;) == nothing);</div>
</div><!-- fragment --> <h2>Benchmarks </h2>
<div class="benchmark-chart" style="min-width: 310px; height: 400px; margin: 0 auto" data-dataset="benchmark.filter.compile.json"> </div> 
</div>
</div>
<a class="anchor" id="a15cd26f8259bdd4306cd0907ef578b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cycle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; n) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine a monadic structure with itself <code>n</code> times. </p>
<p>Given a monadic structure <code>xs</code> and a non-negative number <code>n</code>, <code>cycle</code> returns a new monadic structure which is the result of combining <code>xs</code> with itself <code>n</code> times using the <code>concat</code> operation. In other words, </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(xs, n) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, ... <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, xs)))</div>
<div class="line">                                  <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>Also note that since <code>concat</code> is required to be associative, we could also have written </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(xs, n) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(... <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(xs, xs), xs), xs)</div>
<div class="line">                          <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of <code>concat</code>, <code>empty</code>, is returned. In the case of sequences, this boils down to returning a sequence containing <code>n</code> copies of itself; for other models it might differ.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <code>C</code> and a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{cycle} : M(T) \times C \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to combine with itself a certain number of times.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the number of times to combine the monadic structure with itself. If <code>n</code> is zero, <code>cycle</code> returns <code>empty</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), size_t&lt;2&gt;) == make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad993eca017378409ad0b3a2e6b6807ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove all the elements of a monadic structure that satisfy some predicate. </p>
<p>Given a monadic structure <code>xs</code> and a unary predicate, <code>remove_if</code> returns a new monadic structure equal to <code>xs</code> without all its elements that satisfy the predicate. This is equivalent to <code>filter</code> with a negated predicate, i.e. </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ad993eca017378409ad0b3a2e6b6807ff">remove_if</a>(xs, predicate) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a929370eddd43bb1a4a11b00a7880eadb">filter</a>(xs, negated predicated)</div>
</div><!-- fragment --><h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code> and a predicate of type \( T \to Bool \) for some compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a> <code>Bool</code>, the signature is \( \mathrm{remove\_if} : M(T) \times (T \to Bool) \to M(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to remove some elements from.</td></tr>
    <tr><td class="paramname">predicate</td><td>A unary predicate called as <code>predicate(x)</code>, where <code>x</code> is an element of the structure, and returning whether <code>x</code> should be removed from the structure. In the current version of the library, <code>predicate</code> must return a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ad993eca017378409ad0b3a2e6b6807ff">remove_if</a>(make_tuple(1, 2.0, 3, 4.0), trait&lt;std::is_integral&gt;) == make_tuple(2.0, 4.0), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ad993eca017378409ad0b3a2e6b6807ff">remove_if</a>(just(3.0), trait&lt;std::is_integral&gt;) == just(3.0), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ad993eca017378409ad0b3a2e6b6807ff">remove_if</a>(just(3), trait&lt;std::is_integral&gt;) == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a08e2f3034ed81a7bfff513a5b5f82031"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto remove</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; value) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Remove all the elements of a monadic structure that are equal to some value. </p>
<p>Given a monadic structure <code>xs</code> and a <code>value</code>, <code>remove</code> returns a new monadic structure equal to <code>xs</code> without all its elements that are equal to the given <code>value</code>. <code>remove</code> is equivalent to <code>remove_if</code> with the <code>equal.to(value)</code> predicate, i.e. </p><div class="fragment"><div class="line"><span class="keyword">remove</span>(xs, value) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#ad993eca017378409ad0b3a2e6b6807ff">remove_if</a>(xs, equal.to(value))</div>
</div><!-- fragment --><h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code> and a value of type <code>T</code>, the signature is \( \mathrm{remove} : M(T) \times T \to M(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to remove some elements from.</td></tr>
    <tr><td class="paramname">value</td><td>A value that is compared to every element <code>x</code> of the structure. Elements of the structure that are equal to that value are removed from the structure. This requires every element to be <a class="el" href="structboost_1_1hana_1_1Comparable.html" title="The Comparable concept defines equality and inequality. ">Comparable</a> with <code>value</code>. Furthermore, in the current version of the library, comparing <code>value</code> with any element of the structure must yield a compile-time <a class="el" href="structboost_1_1hana_1_1Logical.html" title="The Logical concept represents types with a truth value. ">Logical</a>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<span class="keyword">remove</span>(tuple_t&lt;int, char, float&gt;, type&lt;char&gt;) == tuple_t&lt;int, float&gt;);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<span class="keyword">remove</span>(just(type&lt;int&gt;), type&lt;char&gt;) == just(type&lt;int&gt;));</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<span class="keyword">remove</span>(just(type&lt;int&gt;), type&lt;int&gt;) == nothing);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acbf4797cf95bb19dfe33a16cf86fe3c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto repeat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; n) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create a monadic structure by combining a lifted value with itself <code>n</code> times. </p>
<p>Given a value <code>x</code>, a non-negative number <code>n</code> and a monadic data type <code>M</code>, <code>repeat</code> creates a new monadic structure which is the result of combining <code>x</code> with itself <code>n</code> times inside the monadic structure. In other words, <code>repeat</code> simply <code>lift</code>s <code>x</code> into the monadic structure, and then combines that with itself <code>n</code> times: </p><div class="fragment"><div class="line">repeat&lt;M&gt;(x, n) == <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a15cd26f8259bdd4306cd0907ef578b47">cycle</a>(lift&lt;M&gt;(x), n)</div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of the <code>concat</code> operation is returned. In the case of sequences, this corresponds to creating a new sequence holding <code>n</code> copies of <code>x</code>.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a> <code>C</code> and <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{repeat}_M : T \times C \to M(T) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The data type of the returned monadic structure. It must be a model of the <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to lift into a monadic structure and then combine with itself.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1Constant.html" title="The Constant concept represents data that can be manipulated at compile-time. ">Constant</a></code> of an unsigned integral type representing the number of times to combine <code>lift&lt;M&gt;(x)</code> with itself. If <code>n == 0</code>, then <code>repeat</code> returns <code>empty&lt;M&gt;()</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(repeat&lt;Tuple&gt;(<span class="charliteral">&#39;x&#39;</span>, size_t&lt;2&gt;) == make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Of course, there can&#39;t be more than one element in an Optional.</span></div>
<div class="line">static_assert(repeat&lt;Optional&gt;(<span class="charliteral">&#39;x&#39;</span>, size_t&lt;2&gt;) == just(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a85ba602a660bdb3bbeb43cc600de3008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto prefix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; z) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value before each element of a monadic structure. </p>
<p>Given a monadic structure <code>xs</code> and a value <code>z</code> called the prefix, <code>prefix</code> returns a new monadic structure. <code>prefix</code> satisfies </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a85ba602a660bdb3bbeb43cc600de3008">prefix</a>(xs, z) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(lift&lt;M&gt;(z), lift&lt;M&gt;(x));</div>
<div class="line">}))</div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the prefix before each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>prefix</code> will return </p><div class="fragment"><div class="line">[z, x1, z, x2, ..., z, xn]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> models, with various levels of interest.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{prefix} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
    <tr><td class="paramname">z</td><td>A value (the prefix) to insert before each element of a monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a85ba602a660bdb3bbeb43cc600de3008">prefix</a>(make_tuple(<span class="stringliteral">&quot;dog&quot;</span>s, <span class="stringliteral">&quot;car&quot;</span>s, <span class="stringliteral">&quot;house&quot;</span>s), <span class="stringliteral">&quot;my&quot;</span>s) ==</div>
<div class="line">    make_tuple(<span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;car&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;house&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b6622ade385d42bf03dd18f226cd080"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto suffix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; z) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value after each element of a monadic structure. </p>
<p>Given a monadic structure <code>xs</code> and a value <code>z</code> (called the suffix), <code>suffix</code> returns a new monadic structure such that </p><div class="fragment"><div class="line"><a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a9b6622ade385d42bf03dd18f226cd080">suffix</a>(xs, z) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a30a6926751dfcafbe2bb67738e2da3c4">concat</a>(lift&lt;M&gt;(x), lift&lt;M&gt;(z));</div>
<div class="line">}))</div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the suffix after each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>suffix</code> will return </p><div class="fragment"><div class="line">[x1, z, x2, z, ..., xn, z]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> models, with various levels of interest.</p>
<h2>Signature </h2>
<p>Given a <a class="el" href="structboost_1_1hana_1_1MonadPlus.html" title="The MonadPlus concept represents Monads with a monoidal structure. ">MonadPlus</a> <code>M</code>, the signature is \( \mathrm{suffix} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
    <tr><td class="paramname">z</td><td>A value (the suffix) to insert after each element of a monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line">static_assert(</div>
<div class="line">    <a class="code" href="structboost_1_1hana_1_1MonadPlus.html#a9b6622ade385d42bf03dd18f226cd080">suffix</a>(make_tuple(1, 2, 3, 4), 0) == make_tuple(1, 0, 2, 0, 3, 0, 4, 0)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><b>hana</b></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1MonadPlus.html">MonadPlus</a></li>
  </ul>
</div>
</body>
</html>
